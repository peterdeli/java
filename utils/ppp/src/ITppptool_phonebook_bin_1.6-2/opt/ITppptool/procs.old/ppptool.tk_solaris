#!/bin/sh

 #\
 PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/local/bin:/opt/sfw/bin:/usr/ucb:/opt/local/exe:/opt/local/pkgs/tk:/opt/ITTOtcltk/bin:/usr/openwin/bin:/usr/X11R6/bin
 #\
 export PATH
 #\
 umask 022
 
 #\
 if [ -z "$DISPLAY" ]; then
 #\
 	echo "`date`: ERROR: DISPLAY environment not set"
 #\
 	exit 1
 #\
 fi
 
 
 #\
 OS=`uname -s`
 
 #\
 umask 022
 #\
 if [ -z "$USER" ] ;then
 		#\
 		echo "USER -> $USER"
 		#\
 			echo "no"
 		#\
 			exit
 		#\
 		if [ $OS = "SunOS" ]; then
 		#\
 			if [ -f "/usr/ucb/whoami" ]; then
 		#\
 				USER_ID=`/usr/ucb/whoami`
 		#\
 			else
 		#\
 				USER_ID=`/bin/who am i | awk '{print $1}'`
 		#\
 			fi
 		#\
 		elif [ $OS = "Linux" ]; then
 		#\
 			USER_ID=`whoami`
 		#\
 		fi
 #\
 else
 	#\
 	USER_ID=$USER
 #\
 fi
 
#\
echo "USER_ID: $USER_ID"
#\
export USER_ID
 
 #\
 CONNECTION_TYPE="ppp"
 #\
 export CONNECTION_TYPE
 
 #\
 PPP_HOME=$HOME/.ppptool
 #\
 export PPP_HOME
 
 #\
 if [ ! -d $PPP_HOME ]; then
 #\
   mkdir $PPP_HOME >> /tmp/ppp.err.$$ 2>&1 
 #\
 	chown $USER_ID $PPP_HOME
 #\
   if [ $? -ne 0 ]; then
 #\
     echo "`date`: Error creating $PPP_HOME" 
 #\
     exit
 #\
   fi
 #\
 else
 #\
   chmod 755 $PPP_HOME # just in case
 #\
 fi
 
 

# exec link target
#\
if [ -h $0 ]; then
#\
	cd `dirname $0`
#\
	basename=`basename $0`
#\
	link_target=`ls -l $basename | awk '{print $NF}'`
#\
	target=`basename $link_target`
#\
	cd `dirname $link_target`
#\
	echo "pppdir = `pwd`"
#\
	PKGHOME=`pwd`
#\
	export PKGHOME
#\
	echo "exec expectk $target  $@" 
	#\
	if [ $# -ge 1 -a "XX$1" = "XX-debug" ]; then
	#\
	exec expectk $target  "$@" 
	#\
	else
	#\
	eval exec expectk $target  "$@"  > /dev/null 2>&1
	#\
	fi
#\
else
#\
	cd `dirname $0`
#\
	echo "pppdir = `pwd`"
#\
	PKGHOME=`pwd`
#\
	export PKGHOME
#\
	target=`basename $0`
#\
	echo "exec expectk $target  $@" 
	#\
	if [ $# -ge 1 -a "XX$1" = "XX-debug" ]; then
	#\
	exec expectk $target  "$@" 
	#\
	else
	#\
	eval exec expectk $target  "$@"  > /dev/null 2>&1
	#\
	fi
#\
fi


proc RandomInit { seed } {
        global randomSeed
        set randomSeed $seed
}
proc Random {} {
        global randomSeed
        set randomSeed [expr ($randomSeed*9301 + 49297) % 233280]
        return [expr $randomSeed/double(233280)]
}
proc RandomRange { range } {
        return [expr int([Random]*$range)]
}

proc build_menus { } {

	##############################
	# Create GUI
	##############################
	wm title . "IT PPP Tool"

	. configure -bg lightGray
	menu .menubar -bg lightGray

	# attach it to the main window
	. config -menu .menubar
	global active_account
	global accounts
	global connection_state
	global bulblist
	global bulbs
	global on_color
	global off_color
	global bulb_colors
	global acct_width 30

	#set bulb_colors { yellow red green blue orange violet pink }
	#set bulb_colors { yellow red lightGreen black }
	#set bulb_colors { black green red #000000 }
	set bulb_colors { black red #000000 }

	set on_color [lindex $bulb_colors 0]
	set off_color [lindex $bulb_colors 1] 

	global save_accounts_prompt
	set save_accounts_prompt "false"

	set connection_state "connecting"

	###############################
	# Create more cascade menus
	##############################
	foreach m {File Edit Accounts Help} {

		# same as 'set File [ menu .. ]'
		set $m [menu .menubar.m$m]

		if { $m == "Help" } {
			# figure out how to put on the right side
			#.menubar add cascade -label "     " -menu .menubar.mFill 
			.menubar add cascade -label $m -menu .menubar.m$m 
		} else {
			.menubar add cascade -label $m -menu .menubar.m$m
		}
	}
	##############################
	# Add Menu Items
	##############################
	#puts "\$File = $File"
	$File add command -label "Save Accounts" -command { 
		puts "Save Settings" 
		set save_accounts_prompt "true"
		if { [save_accounts "save"] == 1 } { 
			set save_accounts_prompt "false"
		}
		set save_accounts_prompt "false"
	}
	$File add command -label "View Log" -command { 

			view_log
	
	} 
	$File add command -label Quit -command {

		puts "Quit"
		if { $connection_state == "connecting" ||  $connection_state == "connected" } {
			puts "connection_state == $connection_state"
			disconnect "User Quit"
		}
		global save_accounts_prompt
		# Check if files need saving
		set save_accounts_prompt "true"
		if { [save_accounts "exit"] == 1 } { 
			set save_accounts_prompt "false"
			exit 
		}
		set save_accounts_prompt "false"
		
	}

	$Edit add command  -label "Manage Accounts" -command { 
		puts "Manage Accounts" 
		manage_accounts
	}
	$Edit add command -label "Edit Preferences" -command { 
		puts "Edit Preferences" 
		edit_prefs
	}

	$Help add command -label "About PPP Tool" -command { 
		tk_messageBox -default "ok" -message \
		"IT PPP Tool\nVersion: XXX" \
		-title "About PPP Tool"
	}
	$Help add command -label "PPP Tool Help" -command  help 

	frame .mid -bg lightGray

	label .acct_label -text "Active Account: No Account loaded" -relief groove -bg lightGray
	pack .acct_label -in .mid -fill x
	#label .color -text "Color" -bg white 
	#pack .color -in .mid

	pack .mid  -fill x

	# account window display
	#set no_acct_txt "No Account loaded"
	set no_acct_txt ""
	set acct_width 30
	set pad_val 3 
	set descr_bg lightGreen
	#	 name
	frame .namef  -bg lightGray
	label .namef.name_l -text "Account:" -bg $descr_bg -relief groove 
	label .namef.name_r -text $no_acct_txt -bg lightBlue -width $acct_width -relief groove 
	pack .namef.name_r -side right -pady [expr $pad_val * 2]
	pack .namef.name_l -side right -pady $pad_val
	.namef.name_r configure -anchor w
	#	 uid
	frame .uidf -bg lightGray
	label .uidf.uid_l -text "User ID:"  -bg $descr_bg -relief groove 
	entry .uidf.uid_r -text $no_acct_txt -bg lightYellow -width $acct_width  -relief groove 
	pack .uidf.uid_r -side right -pady $pad_val
	pack .uidf.uid_l -side right -pady $pad_val
	#.uidf.uid_r configure  -anchor w 


	#	 passwd
	frame .passwdf -bg lightGray
	label .passwdf.passwd_l -text "Password: "  -bg $descr_bg -relief groove 
	entry .passwdf.passwd_r -text $no_acct_txt -bg lightYellow -width $acct_width  \
	-relief groove  -show *
	pack .passwdf.passwd_r -side right -pady $pad_val
	pack .passwdf.passwd_l -side right -pady $pad_val
	#.passwdf.passwd_r configure  -anchor w 

	#	 number
	frame .numberf -bg lightGray
	label .numberf.number_l -text "Phone Number:" -bg $descr_bg  -relief groove 
	label .numberf.number_r -text $no_acct_txt -bg lightBlue -width $acct_width  -relief groove 
	pack .numberf.number_r -side right -pady $pad_val
	pack .numberf.number_l -side right -pady $pad_val
	.numberf.number_r configure  -anchor w 
	#	 domain
	#	 ns1
	#	 ns2
	#	 authtype
	frame .authtypef -bg lightGray
	label .authtypef.authtype_l -text "Authentication Type: "  -bg $descr_bg -relief groove 
	label .authtypef.authtype_r -text $no_acct_txt  -bg lightBlue -width $acct_width  -relief groove 
	pack .authtypef.authtype_r -side right -pady $pad_val
	pack .authtypef.authtype_l -side right -pady [expr $pad_val * 2]
	.authtypef.authtype_r configure  -anchor w 


	pack .namef -in .mid -anchor w -fill x
	pack .uidf -in .mid -anchor w -fill x
	pack .passwdf -in .mid -anchor w -fill x
	pack .numberf -in .mid -anchor w -fill x
	pack .authtypef -in .mid -anchor w -fill x

	frame .connect_frame -bg lightGray

	button .connect -text "Connect" -width 20 \
	-state normal -command connect 

	if { [info exists active_account] != 1 } {
		.connect configure -state disabled
	}

	pack .connect -in .connect_frame
	pack .connect_frame -pady 10

	frame .cframe -bg lightGray
	canvas .cframe.can -width 220 -height 20  -bg lightGray

	set x1 5 
	set y1 5
	set x2 15
	set y2 15
	foreach can_oval { 0 1 2 3 4 5 6 7 8 9 10 11 } {
		.cframe.can create oval $x1 $y1 $x2 $y2 -fill red -width 2 -tag "bulb[set can_oval]"
		incr x1 18 
		set x2 [expr $x1 + 10]	
		lappend bulblist "bulb[set can_oval]"
		set bulbs(bulb[set can_oval],color) [lindex $bulb_colors 0]
		#puts "set bulbs(bulb[set can_oval],color) [lindex $bulb_colors 0]"
		#puts "bulbs(bulb[set can_oval],color) == $bulbs(bulb[set can_oval],color)" 
	}
	pack .cframe.can
	pack .cframe 

	frame .modembutton_text
	foreach modem_text { HS AA CD OH RD SD TR MR RS CS SYN FAX } {
		label .modembutton_text._$modem_text -text $modem_text -bg black -fg white -font {times 6}
		pack .modembutton_text._$modem_text -side left
	}
	pack .modembutton_text 

	frame .footer -bg lightGray
	label .footer.footer_l -text "Status:" -relief groove -bg lightGray
	label .footer.footer_r -text "No connection" -relief groove -bg lightGray
	pack .footer.footer_l -side left 
	pack .footer.footer_r -side left -fill x -expand 1
	.footer.footer_r configure -anchor w -justify left	
	pack .footer -anchor s -side bottom -fill x -expand 1 -pady 5

	global menubar_widget
	set menubar_widget .menubar 
	global acct_widget
	set acct_widget $Accounts

	add_accounts
	set_active


}

proc save_prefs { } {

	global ppp_config_file env \
	ppp_settings ppp_settings_saved \
  port_speeds port_speed modem_port \
  flow_control g_modem_port g_flow_control


	set save_needed "false"

	#set ppp_config_file "$ppp_dir/ppp_settings"
	#set ppp_settings(init_string) "atz" 
	#set ppp_settings(connect_string) ""
	#set ppp_settings(port_speed) 38400
	#set ppp_settings(flow_control) hardware
	#set ppp_settings(modem_port) /dev/term/b
	#set ppp_settings(ppp_options) "" 

	foreach { key value } [array get ppp_settings] {
		if { $ppp_settings($key) != $ppp_settings_saved($key) } {
			set save_needed "true"
			break
		}
	}

	if { $save_needed == "true" } {

		set config_w [open $ppp_config_file w]

		puts "Saving ppp prefs"
		foreach { key value } [array get ppp_settings] {
			puts "$key\t$value"
			puts $config_w "$key\t$value"
			set ppp_settings_saved($key) $value
		}
		puts "ppp Prefs Saved"
		close $config_w
		exec chown $env(USER_ID) $ppp_config_file

	} else {
		puts "No Save needed for PPP Prefs"
	}

}

proc save_accounts {prompt_type} {

	#puts "proc save_accounts"
	global save_accounts_prompt env \
	env accounts saved_accounts ppp_settings \
	ppp_dir
	#set ppp_dir "$env(HOME)/.ppptool" 
	global ppp_config_file
	#set ppp_config_file "$ppp_dir/ppp_settings"
	# list
	global active_account \
	account_list saved_account_list \
	account_keys account_file 

	set save_needed false
	set return_status 1

	# compare account_list to saved_account_list
	if { [llength $account_list] != [llength $saved_account_list] } {
		# something changed
		# write out accounts array
		#puts "llength account_list != llength saved_account_list"
		set save_needed true

	} else {

		# number of accounts equal, but may have different names
		#puts "account_list == saved_account_list"
		foreach account $account_list {
			if { [lsearch $saved_account_list $account] == -1 } {
				#puts "lsearch saved_account_list $account == -1"
				set save_needed true
				break
			} else {
				#puts "lsearch saved_account_list $account != -1"
				continue
			}
		}
	}

	if { $save_needed == "false" } {
		puts "save_needed == false"
		foreach { key value } [array get accounts] {
			puts "Key=$key, value=$value"
			# we should find a match for each
			# if not, something was deleted
			#puts "info exists saved_accounts($key) :?"
			#puts "saved_accounts($key) == $value :?"
			if { [info exists saved_accounts($key)] != 1 } {
				puts "save_needed: info exists saved_accounts($key) != 1"
				set save_needed true
				break
			} elseif { $saved_accounts($key) != $value } {
				puts "480, $saved_accounts($key) != $value, key==$key"
				# don't flag 'status'
				if {  [lindex [split $key  ","] 1] == "status" } {
						set acct_value [string compare  $value "active"]
						puts "acct_value = $acct_value" 
						set saved_key	 [string compare $saved_accounts($key) "active"]
						puts "saved_key	== $saved_key" 
					if { $acct_value == 0 ||  $saved_key == 0 } {
						puts "key $key, $value $value 489"
						#save it and continue without flagging 'save needed'
						# set saved_account to inactive
						#puts "Account list changed, Saving account info .."
						set account_w [open $account_file w] 
						puts "writing to $account_file:"
						foreach account_name $account_list  {
							foreach key [set account_keys] {
								if { [info exists accounts($account_name,$key)] } {
									#puts "$key\t$accounts($account_name,$key)"
									puts $account_w "$key\t$accounts($account_name,$key)"
									# set save_accounts to current values
									set saved_accounts($account_name,$key) $accounts($account_name,$key)
								} else {
									set accounts($account_name,$key) ""
									#puts "$key\t$accounts($account_name,$key)"
									puts $account_w "$key\t$accounts($account_name,$key)"

									# set save_accounts to current values
									set saved_accounts($account_name,$key) "" 

								}
							}
						}
						# set save_account list to current values
						set saved_account_list $account_list
						puts "Wrote account file $account_file"
						close $account_w
						exec chown $env(USER_ID) $account_file
						# write prefs
						save_prefs
						set save_needed "false"
           set return_status 1
					}

				} else {
					#puts "save_needed: saved_accounts($key) != $value"
					set save_needed true
					#break
				}
			}
		}

		foreach { key value } [array get saved_accounts] {
			#puts "Key=$key, value=$value"
			# we should find a match for each
			# if not, something was added
			#puts "info exists accounts($key) :?"
			#puts "accounts($key) = $value :?"
			if { [info exists accounts($key)] != 1 } {
				#puts "save_needed: info exists accounts($key) != 1"
				set save_needed true
				break
			} elseif { $accounts($key) != $value } {
					#puts "save_needed: saved_accounts($key) != $value"
					set save_needed true
					break
			}
				#puts "save_needed: accounts($key) != $value"
				#puts "accounts($key) != $value"
				#set save_needed true
				#break
		}

	}

	if { $save_needed == "true" } {
		if {  $save_accounts_prompt == "true" } {
			if { $prompt_type == "exit" } {
	       set warning_return [tk_messageBox -default yes \
           -type yesnocancel -icon warning \
           -message "To save your changes:\n\n\
                     Click YES to save then exit\n\
                     Click NO to exit without saving\n\
                     Click CANCEL to return to PPP Tool\n" \
           -title "Unsaved Changes"]
			} elseif { $prompt_type == "save" } {

	       set warning_return [tk_messageBox -default ok \
           -type okcancel -icon warning \
           -message "Would you like to save your changes? \n\n\
                     OK to save\n\
                     CANCEL to return to PPP Tool\n" \
           -title "Unsaved Changes"]

			}

        if {"$warning_return" == "yes" || "$warning_return" == "ok"} {

						puts "Account list changed, Saving account info .."
						set account_w [open $account_file w] 
						puts "writing to $account_file:"
						foreach account_name $account_list  {
							foreach key [set account_keys] {
								if { [info exists accounts($account_name,$key)] } {
									#puts "$key\t$accounts($account_name,$key)"
									puts $account_w "$key\t$accounts($account_name,$key)"

									# set save_accounts to current values
									set saved_accounts($account_name,$key) $accounts($account_name,$key)

								} else {
									set accounts($account_name,$key) ""
									#puts "$key\t$accounts($account_name,$key)"
									puts $account_w "$key\t$accounts($account_name,$key)"

									# set save_accounts to current values
									set saved_accounts($account_name,$key) "" 

								}
							}
						}
						# set save_account list to current values
						set saved_account_list $account_list

						puts "Wrote account file $account_file"
						close $account_w
						exec chown $env(USER_ID) $account_file

						# write prefs
						save_prefs
						set save_needed "false"
           set return_status 1

        } elseif {"$warning_return" == "no"} {
           set return_status 1
        } elseif {"$warning_return" == "cancel"} {
           set return_status 0
        }
	
		}

} else {
		puts "No save needed"
	set save_needed "false"
}

	return $return_status

}

proc read_ip_up { } {
	#puts "read_ip_up"
	global ip_up_file	\
			ppp_interface \
			serial_port \
			port_speed \
			ip_address \
			remote_ip_address \
			mtu

		#if_name=$1
		#tty_device=$2
		#speed=$3
		#local_ip=$4
		#remote_ip=$5
		#ipparam=$6
		#DNS1=$DNS1
		#DNS2=$DNS2

		set max_retries 10
		for { set i 0 } { $i < $max_retries } { incr i } {
			puts "Checking for $ip_up_file"
			if { [file exists $ip_up_file] != 1 } {
				sleep 5
			} else {
				break
			}
		}

		if { [file exists $ip_up_file] != 1 } {
			puts "file $ip_up_file not found"
			return -1
		}

			puts "opening file $ip_up_file"
			set ip_fd [open $ip_up_file r]
			while { [gets $ip_fd line] != -1 } {
				#puts $line
				set ip_up_array([lindex [split $line "="] 0]) [lindex [split $line "="] 1]
			}
			close $ip_fd

			#puts "remote_ip_address $ip_up_array(remote_ip)"
			#puts "ip_address $ip_up_array(local_ip)"
			#puts "ppp_interface $ip_up_array(if_name)"
			#puts "serial_port $ip_up_array(tty_device)"

			set remote_ip_address $ip_up_array(remote_ip)
			set ip_address $ip_up_array(local_ip)
			set ppp_interface $ip_up_array(if_name)
			set serial_port $ip_up_array(tty_device)
			set port_speed $ip_up_array(speed)

			# get mtu
			catch { set ifconf [exec ifconfig $ppp_interface] }
			if { [info exists ifconf] == 1 } {
				set ifconf_split [split $ifconf " "] 
				set mtu [lindex $ifconf_split [expr [lsearch $ifconf_split mtu] + 1]]
				set ip_up_array(mtu) $mtu
			}
			
			return 0
}

proc get_helptext { } {

return "\
<b>ITppptool Help\n\
\n\
\n\
PPPtool is a graphical interface for connecting to remote networks\n\
via dialup modem.\n\
\n\
The Main window consists of a Menu, a display of active account \n\
information, the 'Connect/Disconnect' Button, some mock \n\
'status lights', and a 'status' line.\n\
\n\
<b>Menu Items\n\
\n\
The Menu bar contains four menus:\n\
\n\
1. 'File'\n\
2. 'Edit',\n\
3. 'Accounts'\n\
4. 'Help'.\n\
\n\
\n\
The 'File' menu contains three items:\n\
\n\
1. Save Accounts\n\
2. View Log\n\
3. Exit\
\n\
\n\
The 'Edit' menu contains two items:\n\
\n\
1. Manage Accounts\n\
2. Edit Preferences\
\n\
\n\
The 'Accounts' menu is a dynamic menu and holds the names of all accounts\
which have been created.\n\
\n\
\n\
The 'Help' menu contains two items:\n\
\n\
1. 'About PPP Tool'\n\
2. 'PPP Tool Help'\n\
\n\
\n\
<b>Using ITppptool\n\
\n\
\n\
<b>I. Creating Accounts\n\
\n\
To create a new account, Select 'Edit/Manage Accounts'\n\
Click on 'New'. A window will appear with the following fields:\n\
( ** denotes a required field )\n\
\n\
\[ ** Account Name \]: Enter the name of the account\n\
\[ ** User ID \]: Enter the login name or ID of the account\n\
\[ Password \]: Enter the password of the account ( if one exists )\n\
\[ ** Phone Number \]: Enter the Phone Number of the account\n\
\[ DNS Domain Name \]: Enter the domain name of the account ( if one exists )\n\
\[ DNS Search Domains \]: Enter any domains which DNS should search\n\
\[ Account Nameserver #1 \]: Enter a primary nameserver for the account\n\
\[ Account Nameserver #2 \]: Enter a secondary nameserver for the account\n\
\n\
Near the bottom of the window are the following checkbuttons:\n\
\n\
\[ ** Authentication Type \]: Select the authentication protocol or method\n\
\[ Default Route \]: If selected, adds a 'default route' option to pppd\n\
\[ Create /etc/resolv.conf \]: If selected, copies the DNS information to /etc/resolv.conf\n\
\n\
\n\
<b>II.   Saving Accounts\n\
\n\
To save the current account information to the account file,\n\
select File/Save Accounts. If there have been any changes to\n\
the accounts, a prompt will pop up to confirm the save.\n\
Clicking 'Yes' will save the account data, clicking 'Cancel' will\n\
not save the account data and return to PPP tool.\n\ 
\n\
\n\
<b>III.  Editing Accounts\n\
\n\
To make changes to an account, first select Edit/Manage Accounts.\n\
Click on an account name in the window, then click on 'Edit'\n\
A window will appear with the account information.\n\
Edit any fields or select/deselect any items, then click on 'Save Edits'\n\
The window will close and the changes will be saved in the currently\n\
running program, but will NOT be save to the accounts file.\n\
To save the changes to the accounts file, select 'File/Save Accounts' and\n\
click on the 'OK' button\n\.
\n\
\n\
<b>IV.  Deleting Accounts\n\
\n\
To delete and account, first select Edit/Manage Accounts.\n\
Click on an account name in the window, then click on 'Delete'\n\
The account will be deleted in the currently running program, but will\n\
NOT be saved to the accounts file.  To save the changes to the accounts\n\
file, select 'File/Save Accounts' and click on the 'OK' button\n\.
\n\
\n\
<b>V.    Making an Account Active\n\
\n\
To make an account active means to make it available for connecting.\n\
There are two ways to do this:
1. Select the account from the 'Accounts' menu item in the main window.
2. In the 'Account Manager' window, select the account and click the\n\
'Make Active' button.\n\
\n\
\n\
<b>VI.   Preferences\n\
\n\
Upon first starting ppptool, a set of default preferences will be loaded.\n\
To make sure the correct settings are in effect, check the preferences\n\
window by selecting 'Edit/Edit Preferences'.\n\
The settings in the preferences are:\n\
\n\
Modem Port (required):  This is the port to which the modem is connected.\n\
Flow Control:  hardware, software, or none.\n\
Port Speed (required)\n\
Init String: Enter any modem initialization string here.\n\
Connect String: Reserved for future use\n\
PPP options: Reserved for future use\n\
\n\n\
<b>VII.  Connecting with PPPtool\n\
\n\
To initiate a connection, follow these steps:\n\
1. Select an account and make it active ( See V. above )\n\
2. Make sure your modem is connected to the correct port, and that\n\
the correct cable is connected between the modem and the computer.
3. Verify the account information is correct, then click on the 'Connect' Button.\n\
4. If possible, turn up the volume on the modem so that you can hear it going
off-hook, dialing, and connecting.\n\
5. Monitor the 'Status' line at the bottom of the main window, and the log\n\
window as well ( File/View Log ).\n\
\n\
\n\
<b>VIII. Exiting PPPtool\n\
\n\
To exit PPPtool, select 'File/Exit'. If there is any account information\n\
which has not been save to the account file, a dialog will pop up asking\n\
whether to save, cancel, or return to PPPtool. Clicking 'Yes' will save\n\
the account settings to the file. Clicking 'No' will exit PPPtool without\n\
saving the account changes, and clicking 'Cancel' will return to PPPtool\n\
without saving any changes to the accounts file.\n\
\n"
}

proc help { } {
		
		toplevel .help_win 
		wm title .help_win "ITppptool help"
		frame .help_win.help_frame -relief flat
		text .help_win.help_text -wrap word -relief sunken -borderwidth 2 \
		-yscrollcommand { .help_win.scroll_y set} \
		-height 20 -width 65 -setgrid true
		scrollbar .help_win.scroll_y -command ".help_win.help_text yview"
		pack .help_win.help_text -in .help_win.help_frame -side left -pady 1m -fill both
		pack .help_win.scroll_y -in .help_win.help_frame -side right -fill y

		frame .help_win.button_frame -relief flat
		button .help_win.close_button -text "Close" -command {\
			destroy .help_win
		}
		pack .help_win.close_button -side bottom -in .help_win.button_frame \
		-ipadx 2 -padx 2

		pack .help_win.help_frame .help_win.button_frame -side top

		.help_win.help_text tag configure bold \
		 -font  -*-times-bold-r-normal--*-160-* 

		.help_win.help_text tag configure normal \
		-font -*-times-medium-r-normal--*-160-*

		set helptext [split [get_helptext] "\n"]
		foreach line $helptext {

			if { [string first "<b>" $line] != -1 } {
				regsub -all "<b>" $line "" newline
				.help_win.help_text insert end $newline bold 
				#.help_win.help_text insert end "\n" 
			} else {
				.help_win.help_text insert end $line normal
				.help_win.help_text insert end "\n" 
			}
		}
}

proc manage_accounts { } {

		global accounts account_list active_account
		# create win
		# add r/l frames
		# add text & scroll on left
		# add buttons on right
		# add account names to scroll text
		# map buttons to commands
		# create account window w/entry widgets,
		# label/entry for each acct field

	if { [winfo exists .account_manager_win] } { 
		 catch { wm deiconify .account_manager_win }	
		 catch { wm raise .account_manager_win }
		 return
	}

   toplevel .account_manager_win
   wm title .account_manager_win "Account Manager"

   # Two frames, one for a scrolling list of accounts, the other for the buttons

   frame .account_manager_win.account_frame
   pack .account_manager_win.account_frame -side left -padx 1m -pady 1m

   listbox .account_manager_win.account_list -yscrollcommand \
      ".account_manager_win.yscroll_bar set" -xscrollcommand \
			".account_manager_win.xscroll_bar set"
   .account_manager_win.account_list configure -height 10

   scrollbar .account_manager_win.yscroll_bar -command \
      ".account_manager_win.account_list yview" -relief sunken
   .account_manager_win.yscroll_bar set 5 5 0 4

   scrollbar .account_manager_win.xscroll_bar -command \
      ".account_manager_win.account_list xview" -relief sunken \
			-orient horizontal
   .account_manager_win.xscroll_bar set 5 5 0 4

   pack .account_manager_win.yscroll_bar -in .account_manager_win.account_frame \
      -side left -fill y
   pack .account_manager_win.xscroll_bar -in .account_manager_win.account_frame \
      -side bottom -fill x
   pack .account_manager_win.account_list \
      -in .account_manager_win.account_frame -side left 

   bind .account_manager_win.account_list <ButtonRelease-1> {
			if { [string length \
						[.account_manager_win.account_list curselection]] > 0 } {
					set selected_account [list [selection get]]
					puts "selected_account = $selected_account"
					.account_manager_win.delete_button configure -state normal
					.account_manager_win.edit_button configure -state normal	
					.account_manager_win.select_button configure -state normal
			} else {
					.account_manager_win.delete_button configure -state disabled
					.account_manager_win.edit_button configure -state disabled
					.account_manager_win.select_button configure -state disabled
			}
   }

   bind .account_manager_win.account_list <Double-ButtonPress-1> {
      set active_account $selected_account
			set_account $active_account
      #.account_frame.account_button configure -text $active_account
      destroy .account_manager_win
   }

   foreach account [set account_list] {
		if { $accounts($account,status) != "DELETED" } {
      .account_manager_win.account_list insert end "$accounts($account,name)"
		}
   }

  frame .account_manager_win.button_frame
  pack .account_manager_win.button_frame -padx 1m -pady 1m

  button .account_manager_win.select_button -text "Make Active" \
      -state disabled -command {
				 puts "selected_account = $selected_account"
         set active_account $selected_account
         #.account_frame.account_button configure -text $active_account
				 # check if swan or not - if not, enable password
				 set_account $active_account
         #destroy .account_manager_win
      }
  button .account_manager_win.new_button -text New \
      -command {
				puts "Create New Account"
				create_account
			}
  button .account_manager_win.edit_button -text Edit -state disabled \
      -command {
			puts "Edit Account $selected_account"
			edit_account $selected_account
			#.account_manager_win.edit_button configure -state disabled	
		}
  button .account_manager_win.delete_button -text Delete -state disabled \
      -command {

			puts "Delete Account"
			set current_sel [.account_manager_win.account_list curselection]
			puts "current selection: $current_sel: len: [string length $current_sel]"

			if { [string length $current_sel] != 0  } {

				.account_manager_win.account_list delete \
				[.account_manager_win.account_list curselection]

				#.account_manager_win.account_list delete \
				#[.account_manager_win.account_list index $selected_account]

				delete_account_menu $selected_account 
					# if account is active, adjust front panel values
					puts "Comparing selected account $selected_account to\
					active account $active_account"
					if { $selected_account == $active_account } {
						set active_account ""
						set_account $active_account
					} 
			} 

			.account_manager_win.edit_button configure -state disabled
			.account_manager_win.select_button configure -state disabled
			.account_manager_win.delete_button configure -state disabled			
	}
   button .account_manager_win.close_button -text Close \
      -command {destroy .account_manager_win}
   pack .account_manager_win.select_button .account_manager_win.new_button \
      .account_manager_win.edit_button .account_manager_win.delete_button \
      .account_manager_win.close_button -in .account_manager_win.button_frame \
      -ipadx 2 -ipady 2 -padx 2 -pady 2 -fill x
}



proc delete_account {account_name} {


		#create window
		#name    Account1
		#uid     cbj
		#passwd  bongo
		#number  303 123-4567
		#domain  craig.com
		#ns1     123.456.789.000
		#ns2     987.654.321.000
		#authtype        DES challenge
		#defroute        1

		global accounts
		global account_list
		global account_keys
		global account_strings

		delete_account_menu $account_name

}

proc edit_account {edited_account_name} {


		puts "edit_account"
		#create window
		#name    Account1
		#uid     cbj
		#passwd  bongo
		#number  303 123-4567
		#domain  craig.com
		#ns1     123.456.789.000
		#ns2     987.654.321.000
		#authtype        DES challenge
		#defroute        1
		global edit_account_name
		set edit_account_name $edited_account_name

		global accounts
		global account_list
		global account_keys
		global account_strings
		global authtype
		global defroute
		global resolv
		global active_account
		global required_keys

		#.account_manager_win.account_list selection clear 0 end
		.account_manager_win.edit_button configure -state disabled	
		.account_manager_win.delete_button configure -state disabled
		set top .edit_account
		toplevel [set top] 

    frame [set top].required_key_frame
    label [set top].required_key_frame.required_key -text "Required Fields indicated by '**'"
    pack [set top].required_key_frame.required_key
    pack [set top].required_key_frame -anchor n
	

		foreach key [set account_keys] {

			if { $key == "status" } { continue }
			if { $key == "resolv_file" } { continue }

			set value $account_strings($key)
			set [set key]_frame [set top].[set key]_frame

			frame [set [set key]_frame]

			puts "key = $key"
			if { $key == "authtype" } {
				# radio buttons for
				# pap chap challenge card

				radiobutton [set [set key]_frame].[set key]_radio_pap -text \
				"PAP" -variable authtype -value "pap" -width 11

				pack [set [set key]_frame].[set key]_radio_pap -side right

				radiobutton [set [set key]_frame].[set key]_radio_chap -text \
				"CHAP" -variable authtype -value "chap" -width 11
				pack [set [set key]_frame].[set key]_radio_chap -side right

				radiobutton [set [set key]_frame].[set key]_radio_token -text \
				"Token Card" -variable authtype -value "tokencard" -width 11
				pack [set [set key]_frame].[set key]_radio_token -side right

				label [set [set key]_frame].[set key]_label -text "** $value" 
				pack [set [set key]_frame].[set key]_label -side right

				set authtype $accounts($edit_account_name,authtype)

			} elseif { $key == "defroute" } {

				checkbutton [set [set key]_frame].[set key]_check \
				-text "Set default route" -anchor w -onvalue "1" \
				-offvalue "0" -variable defroute -width 42 

				set defroute $accounts($edit_account_name,defroute)

				pack [set [set key]_frame].[set key]_check -side right

				label [set [set key]_frame].[set key]_label -text $value 
				pack [set [set key]_frame].[set key]_label -side right

			} elseif { $key == "resolv" } {

				checkbutton [set [set key]_frame].[set key]_check \
				-text "Create /etc/resolv.conf from DNS settings" -anchor w -onvalue "1" \
				-offvalue "0" -variable resolv -width 42 

				puts "resolv for account $edit_account_name = \
							$accounts($edit_account_name,resolv)"
				set resolv $accounts($edit_account_name,resolv)

				puts "resolv == $resolv"

				pack [set [set key]_frame].[set key]_check -side right

				label [set [set key]_frame].[set key]_label -text $value 
				pack [set [set key]_frame].[set key]_label -side right

			} else {
				entry [set [set key]_frame].[set key]_entry -width 45

				eval [set [set key]_frame].[set key]_entry insert 0 \
				\"$accounts($edit_account_name,$key)\"

				pack [set [set key]_frame].[set key]_entry -side right

        if { [lsearch $required_keys $key] != -1 } {
          label [set [set key]_frame].[set key]_label -text "** $value"
        } else {
          label [set [set key]_frame].[set key]_label -text $value
        }

				pack [set [set key]_frame].[set key]_label -side right
				pack [set [set key]_frame].[set key]_entry -anchor w
			}

			pack [set [set key]_frame] -fill x -expand 1 -pady 5
		}

		frame [set top].button_frame
		button [set top].button_frame.save -text "Save Edits" -command {

			puts "Save Edits"
			# get all entries
			# Check if 'name' has been changed
			# if so, lreplace old account name from account_list
			# add new account name
			# add to accounts array and account_list
			global edit_account
			global edit_account_name
			global authtype
			global defroute
			global resolv
			global active_account

      # check if name is already taken
      set new_account_name [list [.edit_account.name_frame.name_entry get]]

      if { $new_account_name == "" } {
        tk_messageBox -type ok -icon error -title "Missing Account Name" \
        -message  "Please Enter an Account Name"
        return
      } elseif { [string length $new_account_name] < 1 } {
        tk_messageBox -type ok -icon error -title "Missing Account Name" \
        -message  "Please Enter an Account Name"
        return

      }

			#set new_account_name {}
			set delete_account_flag "true"
			foreach key [set account_keys] {
					# popup for required fields
					if { $key == "status" } { continue }
					if { $key == "resolv_file" } { continue	}
					if { $key == "authtype" } {
            if { [string length $authtype] < 1 } {
              tk_messageBox -type ok -icon error -title \
              "$account_strings($key) Required" -message  \
              "Please Enter $account_strings($key)"
              return
            } else {
              set edit_account($key) $authtype
            }
					} elseif { $key == "defroute" } {
						set edit_account($key) $defroute
					} elseif { $key == "resolv" } {
						set edit_account($key) $resolv
					} else {
								set [set key]_frame .edit_account.[set key]_frame
								set key_value [[set [set key]_frame].[set key]_entry get]
								
                if { [lsearch $required_keys $key] != -1 && \
															[string length $key_value] < 1 } {
                    tk_messageBox -type ok -icon error -title \
                    "$account_strings($key) Required" -message  \
                    "Please Enter $account_strings($key)"
                    return
								}
								puts "=====> $key: $key_value" 
								set edit_account($key) $key_value 
								if { $key == "name" } { 
									set new_account_name  [list $key_value] 
									set new_account_string $key_value
									set old_account_string $accounts($edit_account_name,name) 
									set replace_index [lsearch $account_list $edit_account_name]
									# Check if name has changed
									if { $edit_account_name != $new_account_name } {
										puts "replacing $edit_account_name with $new_account_name\
										at index $replace_index"
										set account_list [lreplace $account_list $replace_index \
										$replace_index  $new_account_name]
										puts "account_list == $account_list"

										# save resolv_file name from old account
										set edit_account(resolv_file) \
										$accounts($edit_account_name,resolv_file)
										set edit_account(status) \
										$accounts($edit_account_name,status)

									} else {
										# name has not changed, don't delete from accounts
										# in delete_account_menu
										set delete_account_flag "false"
									}
								}


					}
						
			}




			if { $delete_account_flag == "false" } {

				foreach { key value } [array get edit_account] {
					puts "accounts($new_account_name,$key) = $value" 
					set accounts($new_account_name,$key) $value 
				}
				set_account $new_account_name

				# write resolv file in case changed
				write_resolv_file $accounts($new_account_name,name)	

			} else {
					
				# add to accounts
				puts "account name: $new_account_name"
				puts "account string: $new_account_string"
				set accounts($new_account_name,name) $new_account_string

				foreach { key value } [array get edit_account] {
					puts "accounts($new_account_name,$key) = $value" 
					set accounts($new_account_name,$key) $value 
				}
				# write resolv file in case changed
				write_resolv_file $accounts($new_account_name,name)	

				# delete old account	
				set deleted_index [delete_account_menu $edit_account_name] 
				# add to Accounts menu and acct manager
				add_account_menu $new_account_name $deleted_index

				# remove from account list
				set account_box_items [.account_manager_win.account_list get 0 end]
				foreach item $account_box_items {
					if { $item == $old_account_string } {
						puts "deleting $item from account list at index \
						[lsearch $account_box_items $item]"
						.account_manager_win.account_list delete \
						[lsearch $account_box_items $item]
					}
				}
				
				.account_manager_win.account_list insert $replace_index "$accounts($new_account_name,name)"

				# if account is active, adjust front panel values
				puts "Comparing edited account $edit_account_name to\
				active account $active_account"
				if { $edit_account_name == $active_account } {
					set active_account $new_account_name
					set_account $new_account_name
				}
				set edit_account_name $new_account_name
			}

				.account_manager_win.edit_button configure -state normal	
				.account_manager_win.delete_button configure -state normal
				destroy .edit_account 
		}

		button [set top].button_frame.close -text "Close" -command {
				.account_manager_win.edit_button configure -state normal	
				.account_manager_win.delete_button configure -state normal
				destroy .edit_account 
		}

		pack .edit_account.button_frame.close -side right 
		pack .edit_account.button_frame.save -side left 
		pack .edit_account.button_frame -side bottom -pady 10 

}

proc create_account { } {
		#create window
		#name    Account1
		#uid     cbj
		#passwd  bongo
		#number  303 123-4567
		#domain  craig.com
		#ns1     123.456.789.000
		#ns2     987.654.321.000
		#authtype        DES challenge
		#defroute        1

		global accounts
		global account_list
		global account_keys
		global account_strings
		global create_authtype
		global create_defroute
		global create_resolv

		set top .new_account
		toplevel [set top] 
		global required_keys

		frame [set top].required_key_frame
		label [set top].required_key_frame.required_key -text "Required Fields indicated by '**'"
		pack [set top].required_key_frame.required_key
		pack [set top].required_key_frame -anchor n

		foreach key [set account_keys] {

			if { $key == "status" } { continue }
			if { $key == "resolv_file" } { continue }

			set value $account_strings($key)
			set [set key]_frame [set top].[set key]_frame

			frame [set [set key]_frame]

			puts "key = $key"
			if { $key == "authtype" } {
				# radio buttons for
				# pap chap challenge card

				radiobutton [set [set key]_frame].[set key]_radio_pap -text \
				"PAP" -variable create_authtype -value "pap" -width 12

				pack [set [set key]_frame].[set key]_radio_pap -side right

				radiobutton [set [set key]_frame].[set key]_radio_chap -text \
				"CHAP" -variable create_authtype -value "chap" -width 12
				pack [set [set key]_frame].[set key]_radio_chap -side right

				radiobutton [set [set key]_frame].[set key]_radio_token -text \
				"Token Card" -variable create_authtype -value "tokencard" -width 12
				pack [set [set key]_frame].[set key]_radio_token -side right

				label [set [set key]_frame].[set key]_label -text "** $value" 
				pack [set [set key]_frame].[set key]_label -side right
				set create_authtype ""

			} elseif { $key == "defroute" } {

				set create_defroute 0
				checkbutton [set [set key]_frame].[set key]_check \
				-text "Set default route" -anchor w -onvalue "1" \
				-offvalue "0" -variable create_defroute -width 42 

				pack [set [set key]_frame].[set key]_check -side right

				label [set [set key]_frame].[set key]_label -text $value 
				pack [set [set key]_frame].[set key]_label -side right

			} elseif { $key == "resolv" } {

				checkbutton [set [set key]_frame].[set key]_check \
				-text "Create /etc/resolv.conf from DNS settings" -anchor w -onvalue "1" \
				-offvalue "0" -variable create_resolv -width 42 

				pack [set [set key]_frame].[set key]_check -side right

				label [set [set key]_frame].[set key]_label -text $value 
				pack [set [set key]_frame].[set key]_label -side right

			} else {
				entry [set [set key]_frame].[set key]_entry -width 45
				pack [set [set key]_frame].[set key]_entry -side right
				if { [lsearch $required_keys $key] != -1 } {
					label [set [set key]_frame].[set key]_label -text "** $value" 
				} else {
					label [set [set key]_frame].[set key]_label -text $value 
				}
				pack [set [set key]_frame].[set key]_label -side right
				pack [set [set key]_frame].[set key]_entry -anchor w
			}

			pack [set [set key]_frame] -fill x -expand 1 -pady 5
		}

		frame [set top].button_frame

		button [set top].button_frame.save -text "Create Account" -command {

			# get all entries
			# add to accounts array and account_list
			global new_account
			global create_authtype
			global create_defroute
			global create_resolv
			
			# check if name is already taken
			set new_account_name [list [.new_account.name_frame.name_entry get]]

			if { [lsearch $account_list $new_account_name] != -1 } {
				tk_messageBox -type ok -icon error -title "Duplicate Account Name" \
				-message  "Account name $new_account_name already exists"
				return
			} elseif { $new_account_name == "" } {
				tk_messageBox -type ok -icon error -title "Missing Account Name" \
				-message  "Please Enter an Account Name"
				return

			} elseif { [string length $new_account_name] < 1 } {
				tk_messageBox -type ok -icon error -title "Missing Account Name" \
				-message  "Please Enter an Account Name"
				return

			}


			set account_name {}
			foreach key [set account_keys] {
					puts "-------> Key $key" 

					if { $key == "status" } { continue }
					if { $key == "resolv_file" } { continue }

					# get checkbuttons separate from entry boxes
					if { $key == "authtype" } {
						
						if { [string length $create_authtype] < 1 } {
							tk_messageBox -type ok -icon error -title \
							"$account_strings($key) Required" -message  \
							"Please Enter $account_strings($key)"
							return
						} else {
							set new_account($key) $create_authtype 
						}

					} elseif { $key == "defroute" } {
						set new_account($key) $create_defroute
					} elseif { $key == "resolv" } {
						set new_account($key) $create_resolv
					} else {

								# entry boxes
								set [set key]_frame .new_account.[set key]_frame
								set key_value [[set [set key]_frame].[set key]_entry get]
								puts "----> key: $key key_value: $key_value" 
								set new_account($key) $key_value 

								# required fields
								#account_strings(name) "Account Name:"
								#account_strings(uid) "User ID:"
								#account_strings(passwd) "Password:"
								#account_strings(number) "Phone Number:"
								#account_strings(domain) "DNS Domain Name:"
								#account_strings(ns1) "Account Nameserver #1:"
								#account_strings(ns2) "Account Nameserver #2:"
								#account_strings(authtype) "Authentication Type:"
								#account_strings(defroute) "Default Route:"

								if { $key == "name" } { 
									set account_name  [list $key_value] 
									set account_string $key_value
								}


								if { [lsearch $required_keys $key] != -1 && [string length $key_value] < 1 } {
										
										tk_messageBox -type ok -icon error -title \
										"$account_strings($key) Required" -message  \
										"Please Enter $account_strings($key)"
										return

								}

								
					}
						
			}
					lappend account_list $account_name
					
					# add to accounts
					puts "account name: $account_name"
					puts "account string: $account_string"
					set accounts($account_name,name) $account_string

					foreach { key value } [array get new_account] {
						puts "accounts($account_name,$key) = $value" 
						set accounts($account_name,$key) $value 
					}

					# create resolv.conf name for this account
					set resolv_name "[set ppp_dir]/resolv.conf.[RandomRange 1000]" 
					set accounts($account_name,resolv_file) $resolv_name
					puts "resolv.conf file is $accounts($account_name,resolv_file)"
					# write a resolv.conf file to the file
					write_resolv_file $accounts($account_name,name)	

					# set status
					set accounts($account_name,status) inactive 

					# add to Accounts menu and acct manager
					add_account_menu $account_name "END"
					.account_manager_win.account_list insert end "$accounts($account_name,name)"

				destroy .new_account 
		}

		button [set top].button_frame.close -text "Close" -command {
				destroy .new_account 
		}

		pack .new_account.button_frame.close -side right 
		pack .new_account.button_frame.save -side left 
		pack .new_account.button_frame -side bottom -pady 10 

}

proc write_resolv_file { account_name } {

	puts "write_resolv_file $account_name"
	global accounts	env
	# get account	
	set list_name [list $account_name]
	set resolv_file $accounts($list_name,resolv_file)
	if { [string length $resolv_file] < 1 } {
		# create file
		puts "resolv_file value has 0 length"
	}
	set domain $accounts($list_name,domain)
	set search $accounts($list_name,search)
	set ns1 $accounts($list_name,ns1)
	set ns2 $accounts($list_name,ns2)

	puts "Opening resolv_file $resolv_file"
	if { [catch { set resolv_fd [open $resolv_file w] } err] != 0 } {
		puts "Unable to create $resolv_file: $err"
		return -1
	}
	puts $resolv_fd "# resolv.conf file generated by ppptool"
	puts $resolv_fd "domain $domain"
	if { [string length $search] < 1 } {
		if { [string length $domain] > 0 } {
			puts $resolv_fd "search $domain"
		}
	} else {
		puts $resolv_fd "search $search"
	}
	puts $resolv_fd "nameserver $ns1"
	puts $resolv_fd "nameserver $ns2"
	close $resolv_fd
	puts "Created resolv_file $resolv_file"

	return 0

}


proc blink_single {bulb } {

	global connection_state
	global incr_value
	global bulblist
	global on_color
	global off_color
	global bulb_colors 
	global after_interval
	global bulbs

		set after_interval [RandomRange 500 ] 


		if { [lsearch $bulb_colors $bulbs($bulb,color)] == [expr [llength $bulb_colors] - 1] } {
			set bulbs($bulb,color) [lindex $bulb_colors 0]
		} else {
			set bulbs($bulb,color) [lindex $bulb_colors [expr [lsearch $bulb_colors $bulbs($bulb,color)]  + 1]]
		}

		if { $after_interval > 250 } {
			.cframe.can itemconfigure $bulb -fill $bulbs($bulb,color) 
		}

		if { $connection_state != "connecting" &&  $connection_state != "connected" } {
			.cframe.can itemconfigure all -fill black 
		} else {
			after $after_interval blink_single $bulb
		}
	

}


proc init_blinking_bulbs { } {

	global connection_state
	global incr_value
	global bulblist
	global bulbs
	global on_color
	global off_color
	global bulb_colors 
	global after_interval

	# set different intervals

	foreach bulb $bulblist {

		#puts "bulb $bulb"
		set after_interval [RandomRange 1000] 

		if { [lsearch $bulb_colors $bulbs($bulb,color)] == [expr [llength $bulb_colors] - 1] } {
			#puts "bulbs($bulb,color) = $bulbs($bulb,color)"
			set bulbs($bulb,color) [lindex $bulb_colors 0]
		} else {
			set bulbs($bulb,color) [lindex $bulb_colors [expr [lsearch $bulb_colors $on_color]  + 1]]
		}

			if { $bulb != "bulb0" && $bulb != "bulb3" && $bulb != "bulb10"  } {	
				#puts "init_blinking: .cframe.can itemconfigure $bulb -fill $bulbs($bulb,color)" 
				.cframe.can itemconfigure $bulb -fill $bulbs($bulb,color) 
				#after $after_interval blink_single $bulb
				blink_single $bulb
			} else {
				#puts "Constant: .cframe.can itemconfigure $bulb -fill green" 
				if { $bulb == "bulb0" || $bulb == "bulb3" } {
					.cframe.can itemconfigure $bulb -fill green 
				} else {
					.cframe.can itemconfigure $bulb -fill yellow 
				}
			}
	}
}


proc edit_prefs { } {

	global ppp_settings
	global ppp_settings_saved
	global modem_port
	global flow_control

	global g_modem_port
	global g_flow_control

	global port_speeds
	global port_speed
	puts "Modem port = $ppp_settings(modem_port)"

	if { [winfo exists .prefs] } { 
		 catch { wm deiconify .prefs }	
		 catch { wm raise .prefs }
		 return
	} 
		toplevel .prefs

		frame .prefs.pref_frame


			## Menubutton items ##

		foreach ppp_setting { modem_port flow_control port_speed } {

				set button_descr "[lindex [split $ppp_setting '_'] 0] [lindex [split $ppp_setting '_'] 1]"
				#set ppp_settings(modem_port) /dev/term/b
				frame .prefs.pref_frame.[set ppp_setting]_frame

				if { [info exists ppp_settings($ppp_setting)] == 1 } {
					puts "$ppp_setting = $ppp_settings($ppp_setting)"
					set [set ppp_setting]_button_text $ppp_settings($ppp_setting)
				} else {
					puts "$ppp_setting = $ppp_settings($ppp_setting)"
					set [set ppp_setting]_button_text "Select $button_descr" 
				}
				menubutton .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting] \
				-text [set [set ppp_setting]_button_text] \
				-menu .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting].menu \
				-relief raised  -width 25 

				pack .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting] -side right 
				label .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_label -text $button_descr
				pack .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_label -side right
				#.prefs.pref_frame.[set ppp_setting]_frame.modem_port configure -anchor w	


				pack .prefs.pref_frame.[set ppp_setting]_frame -fill x -expand 1 -pady 2
				eval { set [set ppp_setting]_menu \
				[menu .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting].menu -tearoff 0] }

				if { $ppp_setting == "modem_port" } {
					foreach modem_port [exec ls /dev/term] {
							set modem_port "/dev/term/[set modem_port]"
							puts "[set ppp_setting]_menu add command -label $modem_port -command"
							puts "ppp_settings: [array names ppp_settings]"

							eval { [set [set ppp_setting]_menu] add radio -label $modem_port -variable modem_port \
											-value $modem_port -command {
												.prefs.pref_frame.modem_port_frame.modem_port configure -text $modem_port
											}
							}
					}
					set modem_port $ppp_settings(modem_port)
				} elseif { $ppp_setting == "flow_control" } {

					foreach flow_control { hardware software none } {
							puts "[set ppp_setting]_menu add command -label $flow_control -command"
							puts "ppp_settings: [array names ppp_settings]"

							eval { [set [set ppp_setting]_menu] add radio -label $flow_control -variable \
											flow_control  -value $flow_control -command {
												.prefs.pref_frame.flow_control_frame.flow_control \
												configure -text $flow_control
											}
							}
					}
					set flow_control $ppp_settings(flow_control)

		} elseif { $ppp_setting == "port_speed" } {

				#port_speeds { 38400 57600 115200 230400 } 

				foreach port_speed  $port_speeds  {
					puts "[set ppp_setting]_menu add command -label $port_speed -command"
					puts "ppp_settings: [array names ppp_settings]"

							eval { [set [set ppp_setting]_menu] add radio -label $port_speed \
							-variable port_speed  -value $port_speed -command {
												.prefs.pref_frame.port_speed_frame.port_speed \
												configure -text $port_speed
											}
							}
				}
				set port_speed $ppp_settings(port_speed)

		}
	}

			#### Entry items ###

			set last_width 0 
			foreach ppp_setting { init_string connect_string ppp_options } {
				puts "ppp_setting $ppp_setting"
				set entry_width [string length $ppp_settings($ppp_setting)]
				if { $entry_width < 20 } { set entry_width 25 }
				if { $entry_width > $last_width } { set last_width $entry_width }
			}
				if { $entry_width < $last_width } { set entry_width [expr $last_width + 5] }
				.prefs.pref_frame.modem_port_frame.modem_port configure -width $entry_width
				.prefs.pref_frame.flow_control_frame.flow_control configure -width $entry_width
			

			foreach ppp_setting { init_string connect_string ppp_options } {

				frame .prefs.pref_frame.[set ppp_setting]_frame
				label .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_label -text $ppp_setting 
				entry .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_entry -width $entry_width
				.prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_entry insert 0 $ppp_settings($ppp_setting)

				pack .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_entry -side right 
				pack .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_label  -side right
				pack .prefs.pref_frame.[set ppp_setting]_frame -fill x -expand 1 -pady 2
			}



			#set ppp_settings(port_speed) 38400
			#set ppp_settings(flow_control) hardware

			#set ppp_settings(init_string) "atz" 
			#set ppp_settings(connect_string) ""
			#set ppp_settings(ppp_options) "" 

			pack .prefs.pref_frame -pady 2

		frame .prefs.prefbuttons
		button .prefs.prefbuttons.prefs_save -text "Save" -command {

         global ppp_settings
          global ppp_settings_saved
          global modem_port
          global flow_control

          global g_modem_port
          global g_flow_control

          global port_speeds
          global port_speed

			puts "Save Prefs" 
			foreach ppp_setting { init_string connect_string ppp_options } {
				set ppp_settings($ppp_setting) \
				[.prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_entry get]
				puts "saved ppp_setting $ppp_setting as \
				[.prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_entry get]"
			}
			foreach ppp_setting { modem_port flow_control port_speed } {
				puts "port_speed == $port_speed"
				puts "$ppp_setting = [set [set ppp_setting]]"
				set ppp_settings($ppp_setting) [set [set ppp_setting]] 
				puts "saved ppp_setting $ppp_setting as $ppp_settings($ppp_setting)" 
			}
			
			save_prefs
			## write_global #
			#destroy .prefs
			wm withdraw .prefs
		}

		button .prefs.prefbuttons.prefs_close -text "Close" -command { wm withdraw .prefs }
		pack .prefs.prefbuttons.prefs_save -side left
		pack .prefs.prefbuttons.prefs_close -side right
		pack .prefs.prefbuttons -side bottom -pady 5
	
}

proc log_message { message } {

	catch { [.log_win.log_text insert end $message] }
	catch [.log_win.log_text yview end]

}

proc view_log { } {
	catch { [wm deiconify .log_win] }
}

proc build_log_win { } {

	global accounts
	global active_account


	toplevel .log_win 
	wm title .log_win "PPP Log"
	wm withdraw .log_win

	frame .log_win.log_frame -relief flat
	text .log_win.log_text -relief sunken -borderwidth 2 \
	-yscrollcommand { .log_win.scroll_y set} \
	-height 20 -width 65 -setgrid true
	scrollbar .log_win.scroll_y -command ".log_win.log_text yview"
	pack .log_win.log_text -in .log_win.log_frame -side left -pady 1m -fill both
	pack .log_win.scroll_y -in .log_win.log_frame -side right -fill y

	frame .log_win.button_frame -relief flat
	button .log_win.close_button -text "Close" -command {\
		wm withdraw .log_win
	}

	pack .log_win.close_button -side bottom -in .log_win.button_frame \
	-ipadx 2 -padx 2

	pack .log_win.log_frame .log_win.button_frame -side top



}

proc add_accounts { } {

	global menubar_widget
	global acct_widget
	global color_array
	global account_list
	global accounts

	foreach account $account_list {
		add_account_menu $account "END"
	}
}

proc set_active { } {

	global active_account
	global accounts
	global account_list

	foreach acct $account_list {

		if { [info exists accounts($acct,status)] } {
			if { $accounts($acct,status) == "active" } {
				puts "Setting account $acct to 'active' status"
				set active_account $acct
				set_account $acct
			}
		} else {
				puts "Setting account $acct to 'inactive' status"
				set accounts($acct,status) ""
		}

	}

}

proc set_account {value } {

	# display active account 

	global menubar_widget
	global active_account
	global color_array
	global accounts
	global account_list
	global acct_width

	if { [string length $active_account] > 0 && \
			$accounts($active_account,status) == "DELETED" } {

		.acct_label configure -text "Active Account:"
		.namef.name_r configure -text ""

		.uidf.uid_r delete 0 end 
		.uidf.uid_r configure -state disabled 
		.passwdf.passwd_r configure -state disabled 
		.numberf.number_r configure -text ""
		.authtypef.authtype_r configure -text ""
		.connect configure -state disabled
		return
	}

	if { [string length $active_account] > 0 } {

		.acct_label configure -text \
		"Active Account: $accounts($active_account,name)" \
		-width [expr \
		[string length "Active Account: $accounts($active_account,name)"] + 10]

		set namelabel_width [expr [string length $accounts($active_account,name)] + 5]

		if { [.namef.name_r cget -width] < $namelabel_width } { 
			.namef.name_r configure -width $namelabel_width 
			.uidf.uid_r configure -width $namelabel_width
			.passwdf.passwd_r configure -width $namelabel_width
			.numberf.number_r configure -width $namelabel_width
			.authtypef.authtype_r configure -width $namelabel_width
		} else {
			.namef.name_r configure -width $acct_width
			.uidf.uid_r configure -width $acct_width
			.passwdf.passwd_r configure -width $acct_width 
			.numberf.number_r configure -width $acct_width
			.authtypef.authtype_r configure -width $acct_width
		}

		.namef.name_r configure -text "$accounts($active_account,name)" 


		.uidf.uid_r delete 0 end 
		.uidf.uid_r insert 0 "$accounts($active_account,uid)"

		if { $accounts($active_account,authtype) == "tokencard" } {
			.uidf.uid_r configure -state normal 
			.passwdf.passwd_r delete 0 end 
			.passwdf.passwd_r configure -state disabled 
		} else {
			.uidf.uid_r configure -state normal 
			.passwdf.passwd_r configure -state normal 
			.passwdf.passwd_r delete 0 end 
			.passwdf.passwd_r insert 0 "$accounts($active_account,passwd)" 
		}

		.numberf.number_r configure -text "$accounts($active_account,number)"

		.authtypef.authtype_r configure -text "$accounts($active_account,authtype)"

		if { [info exists active_account] } {
			.connect configure -state normal
		} else {
			.connect configure -state disabled
		}
	} else {
		.acct_label configure -text "Active Account:"
		.namef.name_r configure -text ""

		.uidf.uid_r delete 0 end 
		.passwdf.passwd_r delete 0 end 
		.numberf.number_r configure -text ""
		.authtypef.authtype_r configure -text ""
		.connect configure -state disabled
	}

	# reset active key
	foreach acct $account_list {

		if { $acct == $active_account } {
			puts "Setting account $acct to 'active' status"
			set accounts($active_account,status) "active"
		} else {
			puts "Setting account $acct to 'inactive' status"
			set accounts($acct,status) ""
		}
	}
}

proc set_menu {value } {
	global menubar_widget
	global active_account
	$menubar_widget entryconfigure 3 -label $value
}

proc add_account_menu {name index} {

	global menubar_widget
	global acct_widget
	global active_account
	global accounts

	if { $index != "END" } {
		$acct_widget insert $index radio  -variable active_account \
		-value $name -label $accounts($name,name) -command { set_account $active_account }
	} else {
		$acct_widget add radio  -variable active_account \
		-value $name -label $accounts($name,name) -command { set_account $active_account }
	}
	
	# save menu position

}


proc delete_account_menu {name} {

	global menubar_widget
	global acct_widget
	global active_account
	global accounts
	global account_list
	global account_keys
	global saved_accounts


	# find where it is
	# number of indexes should correspond to llength $account_list
	puts "Looking for menu entry $name"
	set index [$acct_widget index $accounts($name,name)]

	# delete accounts entry
	foreach key $account_keys {
		set accounts($name,$key) DELETED 
		set saved_accounts($name,$key) DELETED 
	}

	# delete account_list entry
	set account_list [lreplace $account_list \
	[lsearch $account_list $name] \
	[lsearch $account_list $name]]

	puts "Deleting index $name at index $index"
	$acct_widget delete $index

	puts "account_list now contains: $account_list"
	puts "accounts now contains:"
	puts [array get accounts]

	set saved_account_list $account_list
	
	# save menu position
	# return index
	return $index

}

# load global settings
proc load_global { } {

	global ppp_dir
	global ppp_config_file
	global ppp_settings
	global ppp_settings_saved
	global port_speeds
	set port_speeds { 38400 57600 115200 230400 } 

	global g_modem_port
	global g_flow_control

	set ppp_settings(init_string) "atz" 
	set ppp_settings(connect_string) ""
	set ppp_settings(port_speed) [lindex $port_speeds 0] 
	set ppp_settings(flow_control) hardware
	set ppp_settings(modem_port) /dev/term/b
	set ppp_settings(ppp_options) "" 

	set ppp_settings_saved(init_string) "atz" 
	set ppp_settings_saved(connect_string) ""
	set ppp_settings_saved(port_speed) [lindex $port_speeds 0] 
	set ppp_settings_saved(flow_control) hardware
	set ppp_settings_saved(modem_port) /dev/term/b
	set ppp_settings_saved(ppp_options) "" 

	set ppp_config_file "$ppp_dir/ppp_settings"

	if { [file exists  $ppp_config_file] != 1 } {
		puts "Creating $ppp_config_file"
		set global_fd [open $ppp_config_file w]
		# put in defaults
		foreach key [array names ppp_settings] {
			puts $global_fd "$key\t$ppp_settings($key)"
		}
		close $global_fd
		exec chown $env(USER_ID) $ppp_config_file
	} else {
		puts "Reading $ppp_config_file"
		set ppp_fd [open $ppp_config_file r]
		while { [gets $ppp_fd line] != -1 } {
			set split_line [split $line "\t"]
			set ppp_settings([lindex $split_line 0]) [lindex $split_line 1]
			set ppp_settings_saved([lindex $split_line 0]) [lindex $split_line 1]
			puts "set ppp_settings([lindex $split_line 0]) [lindex $split_line 1]"
		}
	}

	set g_modem_port ppp_settings(modem_port)
	set g_flow_control ppp_settings(flow_control)

	#pppopts
	# init_string
	# connect_string
	# port_speed
	# flow_control
	# modem_port

}

proc load_current_accts { } {

	global env
	global ppp_dir

	# list
	global saved_account_list

	# array (saved_account_name,key)
	global saved_accounts

	# account file names
	global saved_account_file

	global account_keys

	set saved_account_name ""

	if { [file exists $account_file] } {

		set saved_account_fd [open $account_file r]

				# parse into acct_array
				for { set i 0 } { [gets $saved_account_fd line] != -1 } {incr i} {

					if { [string length $line] < 1 } { continue }
					set field [split $line "\t"]
					set key [lindex $field 0]
					string trim $key
					puts "Key=$key"
					set value [lindex $field 1]
					puts "Value=$value"

					# check key
					if { [lsearch $saved_account_keys $key] == -1 } {
						puts "Invalid key $key found in account file $acct"
						continue
					}

					# make sure account name is same as file prefix
					if { $key == "name" } {
						# New account
						puts "Account $value"
						set saved_account_name $value
						lappend saved_account_list $value
					}
					puts "Adding key '$key' value '$value' to saved_accounts"
					set saved_accounts($saved_account_name,$key) $value
				}

				close $saved_account_fd
	} 
			# done
			puts "Loaded saved_accounts"

}


proc load_accts { } {
	global env
	global ppp_dir
	# list
	global account_list
	global saved_account_list
	set saved_account_list {}
	# array (account_name,key)
	global accounts
	global saved_accounts
	# account file names
	global account_file
	global account_keys

	global active_account

	set account_name ""
	set previous_name ""

	if { [file exists $account_file] } {

		set account_fd [open $account_file r]

				# parse into acct_array
				for { set i 0 } { [gets $account_fd line] != -1 } {incr i} {

					if { [string length $line] < 1 } { continue }
					set field [split $line "\t"]
					set key [lindex $field 0]
					string trim $key
					puts "Key=$key"
					set value [lindex $field 1]
					puts "Value=$value"

					# check key
					if { [lsearch $account_keys $key] == -1 } {
						puts "Invalid key $key found in account file accounts"
						continue
					}

					# make sure account name is same as file prefix
					if { $key == "name" } {
						# New account
						# first check last account
						puts "Account $value"
						set account_name [list $value]
						set previous_name $account_name 
						puts "Adding account name $account_name to account_list"
						lappend account_list $account_name
						puts "Adding account name $account_name to saved_account_list"
						lappend saved_account_list $account_name
							puts "Adding key '$key' value '$value' to accounts"
							set accounts($account_name,$key) $value
							puts "Adding key '$key' value '$value' to saved_accounts"
							set saved_accounts($account_name,$key) $value
					} else {
							puts "Adding key '$key' value '$value' to accounts"
							set accounts($account_name,$key) $value
							puts "Adding key '$key' value '$value' to saved_accounts"
							set saved_accounts($account_name,$key) $value
					}
				}
				close $account_fd

				# verify
				puts "verifying accounts"
				foreach account $account_list {
							foreach key $account_keys {
								puts "key $key"
								puts "account $account"
								if { [info exists accounts($account,$key)] == 0 } {
										puts "key $key not found in accounts file"
										puts "set accounts($account,$key)"
										set accounts($account,$key) ""
								}
								if { $key == "resolv_file" } {
									# check for resolv_file entries?
									if { [file exists $accounts($account,$key)] != 1 } {
										set resolv_name "[set ppp_dir]/resolv.conf.[RandomRange 1000]" 
										set accounts($account,resolv_file) $resolv_name
										write_resolv_file $accounts($account,name)
									}
								}
							}
				}

	} 
			# done
			puts "Loaded accounts"

}

proc log_messages {message} {

  puts "proc log_messages {message} "

   global log_file
   regsub "\r" $message "\n" newline_message 
   set message $newline_message

  if { [info exists message] == 1 } {
     .log_win.log_text insert end "$message\n"
     .log_win.log_text yview end

     set fd [open $log_file a]
     if {$fd == ""} {
        return 0
     }
     puts $fd "$message\n"
     close $fd
  }
}


proc des_countdown { } {

	global seconds_remaining

	if { [winfo exists .des_dialog] != 1 } {  return } 

	if { $seconds_remaining == "null" } {
		

	} elseif { $seconds_remaining == 0 } {
		.des_dialog.time_remaining configure -text "Challenge Entry Interval Expired!"
		#wm withdraw .des_dialog
		#destroy .des_dialog
		return -1
	} else {
		.des_dialog.time_remaining configure -text "Seconds Remaining: $seconds_remaining"
		incr seconds_remaining -1
		after 1000 des_countdown
	}

}

proc down_interface { } {

	global ppp_interface serial_port ip_address
	global ifconfig_cmd

	# check if i/f is up
	if { [info exists $ppp_interface] != 1 } { return }
	if { [string length $ppp_interface] < 1 } { return }
	puts "Taking down interface $ppp_interface"
	
	puts "spawn /usr/bin/pfsh"

	spawn /usr/bin/pfsh
	expect "\$ "

	puts "Sending /usr/sbin/ifconfig $ppp_interface down"
	exp_send "/usr/sbin/ifconfig $ppp_interface down\r"

	expect "\$ "


	set ppp_interface ""
	set ip_address ""

	close $spawn_id

}

proc close_pppd { } {

	puts "proc close_pppd" 
	global ppp_interface serial_port \
	connection_type ip_address spawn_id tip_id \
	pppd_pid pppd_id connection_state \
	link_disconnected  

	if { [info exists connection_type] != 1 } { return }

		if { $connection_type == "pppd" } {
				puts "pkill pppd"
				catch { [exec pkill pppd] }
		} else {
			catch { 
				catch { [exec pkill pppd] }
				set timeout 10
				exp_send "~.\r"
				expect "EOT\]"
				exec pkill tip
			}
		}
	set connection_state "disconnected"	
	set link_disconnected "true"
}

proc disconnect { reason } {
	
	puts "proc disconnect" 

	global accounts
	global active_account 
	global challenge_entered
	global des_response
	global seconds_remaining
	set seconds_remaining 30
	global connection_state
	set challenge_entered "false"
	global pppd_id pppd_pid tip_id

	global ppp_interface serial_port ip_address
	global connection_type
	set connection_state "disconnecting"

	# connection scripts
	pre_disconnect

	.connect configure -text "Connect" -command connect  -state disabled

	log_message "Disconnecting: $reason"
	.footer.footer_r configure -text "Disconnecting: $reason" -justify left
	catch { destroy .des_dialog }

	global backup_resolv
	global manage_resolv

	# restore resolv.conf
	if { $accounts($active_account,resolv) == 1 } {
		if { [info exists backup_resolv] == 1 } {
			if { [file exists $backup_resolv] == 1 } {
				puts "restoring file $backup_resolv"
				exec $manage_resolv restore $backup_resolv
			} 
		} 
	}

	puts "Terminating connection"
	.footer.footer_r configure -text  "Terminating connection, please wait .. "
	puts "close_pppd"
	close_pppd

	# in case monitor_link still running
	sleep 5 
	.connect configure -state normal 

	# connection script
	post_disconnect

	.footer.footer_r configure -text  "Connection closed"
	puts "disconnect done"
}

proc init_modem { } {
		puts "init_modem"

		global ppp_settings
		set init_string "AT &F1"
		set baud_rate "-28800"

		if { [info exists ppp_settings(init_string)] && \
				 [string length $ppp_settings(init_string)] > 2 } {

				set init_string $ppp_settings(init_string)
		} 
	
	set timeout 10
	if { [info exists ppp_settings(port_speed)] } {
		set baud_rate "-[set ppp_settings(port_speed)]"
	} 

	spawn tip $baud_rate $ppp_settings(modem_port)
	sleep 1	
	exp_send "AT\r"
	expect {
			 "OK" { 
						puts "Sending init string $init_string"
					 exp_send "$init_string\r" 
				}
				timeout {
					puts "timeout waiting for OK from AT command"
					catch { exec pkill tip }
					return -1
				}
	}
	expect {
		"OK" {
			exp_send "~.\r"
		}
		"NO CARRIER" {
			set timeout 5
			exp_send "~.\r"
			expect "EOF\]"
			set  connection_state "disconnected"
			log_message $expect_out(buffer)
			.connect configure -state normal -command connect
			puts "Modem connection dropped" 
			return 0
		}
		timeout {
				puts "timeout waiting for OK from AT command"
				catch { exec pkill tip }
				return -1
		}

	}
	expect {
		"EOT\]" {
			puts "Modem initialized"
			return 0
		}
		timeout {
			puts "timeout waiting for tip to close"
			catch { exec pkill tip }
		}

	}
}

proc connect { } {

	global accounts
	global active_account 
	global challenge_entered
	global des_response
	global seconds_remaining
	set seconds_remaining 30
	global connection_state
	set challenge_entered "false"
	global ppp_interface serial_port ip_address

	# pre-connection scripts
	pre_connect

	log_messages "Connecting"
	set connection_state "connecting"
	init_blinking_bulbs
	.footer.footer_r configure -text "Connecting .."

	set connection_state "connecting"
	.connect configure -text "Disconnect" -state disabled -command {
		disconnect "Disconnected by User" 
	} 

	global backup_resolv
	set backup_resolv "" 
	global manage_resolv


	if { $accounts($active_account,resolv) == 1 } {

		# create resolv.conf, backup resolv.conf
		if { [file exists $accounts($active_account,resolv_file)] == 1 } {
			set backup_resolv "/etc/resolv.conf.ppp"
			# backup 'to'
			puts "exec $manage_resolv backup $backup_resolv" 
			exec $manage_resolv backup $backup_resolv 
			# copy 'from'
			puts "exec $manage_resolv copy $accounts($active_account,resolv_file)"
			exec $manage_resolv copy $accounts($active_account,resolv_file)
		} else {
			puts "file exists $accounts($active_account,resolv_file) != 1" 
			set backup_resolv "" 
		}

	}


	# kill any old pppd's
	catch { exec pkill pppd }

	# initialize modem
	if { [init_modem] != 0 } { 
		.footer.footer_r configure -text "Error Initializing Modem" 
		.connect configure -text "Connect" -command connect -state normal
		disconnect "Error Initializing Modem"
		return
	} else {
		.footer.footer_r configure -text "Modem Initialized" 
	}


	if { $accounts($active_account,authtype) == "tokencard" } {
		create_des_dialog
		modempool_connect
	} else {
		isp_connect
	}

}

proc restore_resolv { } {
	global accounts
	global active_account
	global backup_resolv
	exec $restore_resolv $backup_resolv
}

proc backup_resolv { } {
	global accounts
	global active_account
	global backup_resolv
	set backup_resolv [exec $backup_resolv]
}

proc create_resolv { } {
	global accounts
	global active_account
	#account_strings(domain) "DNS Domain Name:"
	#account_strings(ns1) "Account Nameserver #1:"
	#account_strings(ns2) "Account Nameserver #2:"

	exec $create_resolv \
	$account_strings($active_account,domain) \
	$account_strings($active_account,ns1) \
	$account_strings($active_account,ns2) 
}

proc monitor_link { } {
	puts "monitor_link"
	global ppp_interface serial_port ip_address \
	remote_ip_address link_disconnected  mtu port_speed \
	ppp_settings connection_state monitor_done

	set monitor_done "false"
	
	if { $link_disconnected == "true" } { 
		set monitor_done "true"
		return 0 
	}

	if { [info exists mtu] != 1 } { set mtu "" }
	if { [info exists port_speed] != 1 } { 
		set port_speed "" 
	} elseif { [info exists $ppp_settings(port_speed)] != 1 } { 
		set port_speed $ppp_settings(port_speed) 
	}

	set timeout 10
	global ip_up_file
	global ip_down_file
	# global ip_up_array
	# read ip-up output file

	if { [string length $remote_ip_address] < 6 } {
		puts "Unable to monitor link, no valid remote_ip_address"
	}
	# check that ppp_interface is a gateway
	#0.0.0.0         192.168.1.1     0.0.0.0         UG       40 0          0 eth0
	set save ""
	# retry if remote gateway not up immediately
	set max_retries 5 

	for { set j 1 } { $j <= $max_retries } { incr j } {

		puts "link_check $j"
		set gateway_list {}
		set ppp_gateway "false"
		if { $connection_state != "connected" && \
				$connection_state != "connecting" } { 
			puts "monitor_link: connection_state = $connection_state"
			set monitor_done "true"
			return 0 
		}
		set netstat_fd [open "|netstat -rn"]

		while { [gets $netstat_fd line] != -1 } {
				if {	[string first "UG" $line] != -1 || [string first "UH" $line] != -1 } {
					# save all gateways
					lappend gateway_list $line
					if { [string first $ppp_interface $line] != -1 } {
						if { [string first $remote_ip_address $line] != -1 } {
							puts "found $remote_ip_address in $line"
							set ppp_gateway "true"
							break
						}
					}
				}
		}
		catch { close $netstat_fd }
		puts "Gateways: [join $gateway_list \"\n\"]"
		if { $ppp_gateway == "true" } { 
			set j [expr $max_retries + 1]	
			break
		} else {
			#puts "No ppp gateway found, trying again .."
			#.footer.footer_bottom config -text "No ppp gateway found, retrying ($j of $max_retries)" 
			#pack .footer.footer_bottom -anchor s
			sleep 5	
		}

	}

	if { $ppp_gateway == "false" } {
				puts "No gateway found for $ppp_interface"
				set connection_state "disconnected"
				puts "disconnecting .."
				disconnect "No gateway found for $ppp_interface"
				return -1
	} else {
		#destroy .footer.footer_bottom
			.footer.footer_r configure -text \
			"Connected:\n\
			Network Interface: $ppp_interface\n\
			IP address: $ip_address\n\
			MTU: $mtu\n\
			Port Speed: $port_speed\n\
			Remote IP address: $remote_ip_address\n" \
			-font {times 10 bold} -justify left
	}

	log_user 0	
	spawn ping -c 1 $remote_ip_address 
	expect eof 
	log_user 1
	if { [info exists expect_out(buffer)] != 1 || 
		[string first "is alive" $expect_out(buffer)] < 0 } {
					puts "Cannot reach $remote_ip_address, link may have gone down"
					.footer.footer_r config -text "Cannot reach $remote_ip_address, \
					link may have gone down"
					set connection_state "disconnected"
					sleep 2
					puts "disconnecting .."
					disconnect "link may have gone down" 
					return -1
	} else {
				set connection_state "connecting"
				after 10000 monitor_link
	}
}

proc create_ip_up { } {
	global accounts
	set ip_up_file "/etc/ppp/ip-up"
}

proc create_ip_down { } {
	global accounts
	set ip_down_file "/etc/ppp/ip-down"
}

proc isp_connect { } {
	puts "proc isp_connect { } "

	global 	accounts account_list active_account baud_rate 
	global	env flow_control init_string ip_enabled 
	global 	log_file log_messages message modem_port
	global 	nat_transparency_mode network_interface 
	global 	password phone_number
	global	port port_speed spawn_id tokencard_response username
	global baud_rate pppd_config_file username

	global connection_state
	global pppd_id
	global pppd_pid
	global ppp_interface serial_port ip_address

	# create connect script
		# connect '/usr/bin/chat -v REPORT CONNECT ABORT BUSY ABORT "NO CARRIER" "" atdtxxxxxx CONNECT"'
	.passwdf.passwd_r configure -state normal

	global tip_id
	global connection_type
	set connection_type "pppd"
	global ppp_settings

	#set phone_number $accounts($active_account,number)

	# strip out non-numeric
	regsub -all "\[^0-9\]" $accounts($active_account,number) "" phone_number 

	set baud_rate $ppp_settings(port_speed) 
	set pppd_config_file "$env(HOME)/.ppptool/connect.script"
	set port $ppp_settings(modem_port)
	set pppd /usr/bin/pppd
	set pppd_cmd "$pppd file $pppd_config_file"

	.footer.footer_r config -text "Connect: Creating chat script"

	set fd [open $pppd_config_file w]

	set username [.uidf.uid_r get] 
	set password [.passwdf.passwd_r get] 

	if { $username != $accounts($active_account,uid) } {
		set accounts($active_account,uid) $username
	}
	if { $password != $accounts($active_account,passwd) } {
		set accounts($active_account,passwd) $password
	}

	#set username $accounts($active_account,uid) 
	#set password $accounts($active_account,passwd)


	puts "$phone_number $port $baud_rate $pppd_config_file $username $password"

	puts $fd $port
	puts $fd $baud_rate
	puts $fd debug
	puts $fd lock
	puts $fd noproxyarp
	puts $fd updetach
	puts $fd usepeerdns

	# flow control
	switch  $ppp_settings(flow_control) {
		"hardware" { puts $fd crtscts }
		"software" { puts $fd xonxoff }
		"none" { puts $fd  nocrtscts }
	}

	if { $accounts($active_account,defroute) == 1 } {
		puts $fd "defaultroute"
	} else {
		puts $fd "nodefaultroute"
	}
	puts $fd "noipdefault"
	puts $fd "user $username"
	puts $fd "password $password"

	puts $fd "connect '/usr/bin/chat -v REPORT CONNECT ABORT BUSY ABORT \"NO CARRIER\" \"\" atdt$phone_number \"CONNECT\"'"

	close $fd
	set pppd_cmd "$pppd file $pppd_config_file"
	puts "$pppd_cmd"

	.footer.footer_r config -text "Connecting with Chat script"

	eval spawn $pppd_cmd
	set pppd_id $spawn_id

	.footer.footer_r config -text "Starting Process:\n$pppd_cmd" -font {times 10 bold} -justify left
	set ctr 0
	expect_background -i $pppd_id -re  "\[^\r]*\r\n"  {

			if { [string first "is locked by pid" $expect_out(0,string)] != -1 } {
				# get pid and run close_pppd
				#Device /dev/term/b is locked by pid 6482
				#pppd exp6: Device /dev/term/b is locked by pid 6482

				set split_line [split $expect_out(0,string) "\[ \t]*"]
				set lock_pid [lindex $split_line [expr [llength $split_line] -1]] 
				puts "Found locking pid $lock_pid, looking for /var/run/ files with pid"
				# look for file in /var/run containing pid
				foreach f [exec ls /var/run] {
					if { [regexp "pid$" $f] == 1 } {
						# check if file contains pid
						if { [exec cat "/var/run/$f"] == $lock_pid } {
							#send file name to close_pppd
							set ppp_interface [lindex [split $f "."] 0]
							puts "Setting ppp_interface file name to $ppp_interface"
							puts "Running close_pppd"
							close_pppd 	
							break
						}
					}
				}
					
			}

			# look for connection success
			# Connect: sppp0 <--> /dev/term/b
			if { [string first "Connect" $expect_out(0,string)] != -1 } {
					set ppp_interface \
					[lindex [split $expect_out(0,string) " \t"] 1]

					set serial_port \
					[lindex [split $expect_out(0,string) " \t"] 3]
					puts "\n==> PPP Interface: $ppp_interface <==\n"
					puts "\n==> serial port: $serial_port <==\n"
			}

			if {	[string first "local" $expect_out(0,string)] != -1 && \
						[string first "IP address" $expect_out(0,string)] != -1 } {

					set ip_address \
					[string trim [lindex [split $expect_out(0,string) "\[ ]*"] 4]]
					puts "\n==> IP address for interface: $ip_address <==\n"
					.footer.footer_r configure \
					-text "PPP Connected.\nNetwork Interface: $ppp_interface\nIP address: $ip_address" -anchor w -justify left
			}
			# rcvd [IPCP ConfAck id=0x8a <addr 32.100.234.63>]
			# local  IP address 32.100.234.63
			# remote IP address 204.146.246.229
			# pppd exp6: rcvd [IPCP ConfAck id=0x8a <addr 32.100.234.63>]
			# local  IP address 32.100.234.63
			# remote IP address 204.146.246.229

			if {	[string first "remote" $expect_out(0,string)] != -1 && \
						[string first "IP address" $expect_out(0,string)] != -1 } {
					#remote IP address 32.97.116.34
					set remote_ip_address \
					[string trim [lindex [split $expect_out(0,string) "\[ ]*"] 3]]
					puts "\nRemote IP address for interface: $remote_ip_address\n"
					.footer.footer_r configure \
					-text "PPP Connected.\nNetwork Interface: $ppp_interface\nIP address: $ip_address\nRemote IP address: $remote_ip_address" -anchor w -justify left
						.connect configure -state normal -text "Disconnect" -command {
							disconnect "Disconnected by User" 
							set link_disconnected "true" 
						}
						set connection_state "connected"
						set link_disconnected "false" 
						read_ip_up
						monitor_link
						post_connect
			}

			# get pid 
			if { [string first "CONNECT" $expect_out(0,string)] != -1 && \
					[string first "started" $expect_out(0,string)] != -1 } {

					puts "pppd $spawn_id"
					# the pid of the pppd 
					set pid_line [split $expect_out(0,string) "\[ \t]*"] 
					puts "pid_line: $pid_line"

					# get last string of line
					set pid_string [lindex $pid_line end] 
					puts "pid_string: $pid_string"

					set pppd_pid [string trimright [lindex [split $pid_string] 0] ")"]
					puts "pppd_pid: $pppd_pid"
					.connect configure -state normal

			}

			puts "pppd $spawn_id: $expect_out(0,string)"
			log_message $expect_out(0,string)
		}
	
}

proc create_des_dialog { } {

	global accounts
	global active_account 
	global challenge_entered
	global des_response
	global seconds_remaining
	set seconds_remaining 30
	global connection_state
	set challenge_entered "false"
	global ppp_interface serial_port ip_address

 		toplevel .des_dialog -bg lightGray
		entry .des_dialog.des_entry -width 20 -bg lightGray
		label .des_dialog.challenge_label -text "Host:  Challenge:" -bg lightGray
		label .des_dialog.instruction_label -text "\n\
					 Get your DES card ready\n\
					 Enter your authorization number\n\
					 Then get ready to key in the Host Number\n\
					 and Challenge when they appear above\n\n\
					 Then press 'E' and wait for the response string,\n\
					 and enter the 'response' from your DES card\n\
					 into the entry box above" -bg lightGray

		label .des_dialog.time_remaining -text "Waiting for Remote Connection" -bg lightGray
		log_messages "Waiting for Remote Connection"
		button .des_dialog.des_send_button -text "Send Response" \
		-command { 
				global des_response challenge_entered seconds_remaining
				set des_response [.des_dialog.des_entry get]	
				set challenge_entered "true"
				#wm withdraw .des_dialog
				set seconds_remaining "null"
				destroy .des_dialog
		}	
		button .des_dialog.close -text "Close" \
		-command {

			#wm iconify .des_dialog
			set seconds_remaining "null"
			destroy .des_dialog
		}
		pack .des_dialog.challenge_label -anchor n
		pack .des_dialog.des_entry -after .des_dialog.challenge_label
		pack .des_dialog.instruction_label -anchor n
		pack .des_dialog.time_remaining -anchor n
		pack .des_dialog.des_send_button -side left -anchor n
		pack .des_dialog.close -side right -anchor n 
}

proc modempool_connect { } {

	puts "proc modempool_connect { } "

	global ppp_interface serial_port ip_address

	global connection_type
	global connection_state 

	global 	accounts account_list active_account baud_rate \
	env flow_control init_string ip_enabled \
	log_file log_messages message modem_port \
	nat_transparency_mode network_interface \
	password phone_number \
	port port_speed spawn_id tokencard_response username \
	baud_rate pppd_config_file username \
	tip_id pkghome ppp_settings challenge_entered \
	des_response seconds_remaining link_disconnected \
	port_id start_pppd remote_ip_address mtu ip_up_file
	
  set connection_type "tip"
	set pppd_started "false"
	set link_disconnected "false" 
	set mtu 0
	set remote_ip_address "0.0.0.0"

	# remote ip_up_file
	#puts "removing $ip_up_file"

	catch { exec rm $ip_up_file }

	#set ppp_settings(init_string) "atz" 
	#set ppp_settings(connect_string) ""
	#set ppp_settings(port_speed) 38400
	#set ppp_settings(flow_control) hardware
	#set ppp_settings(modem_port) /dev/term/b
	#set ppp_settings(ppp_options) "" 

	set phone_number $accounts($active_account,number)
	set baud_rate $ppp_settings(port_speed) 
	set pppd_config_file "$env(HOME)/.ppptool/connect.script"
	set port $ppp_settings(modem_port) 

	#set username $accounts($active_account,uid) 
	set username [.uidf.uid_r get] 
	if { $username != $accounts($active_account,uid) } {
		set accounts($active_account,uid) $username
	}

	# don't need passwd field

	.passwdf.passwd_r configure -state disabled
	.connect configure -state normal

	puts "$phone_number $port $baud_rate $pppd_config_file $username"
	log_messages "$phone_number $port $baud_rate $pppd_config_file $username"

	set timeout 60
	# close any tip_id's in case
	catch { [exec pkill tip] }
	spawn tip "-$baud_rate" $port 
	log_messages "spawn tip -$baud_rate $port" 
	#set tip_id $spawn_id

	expect {

				"Authentication failed." {
					puts "Check User ID/Password"
					log_message $expect_out(buffer)
					log_message "Check User ID/Password"
					.footer.footer_r configure -text \
					"Authentication failed.\nCheck User ID/Password" -anchor w -justify left
					create_des_dialog
					exp_continue
				}
				"NO CARRIER" {
					set  connection_state "disconnected"
					sleep 5	
					log_message $expect_out(buffer)
					.connect configure -state normal -command connect
					puts "Modem connection dropped" 
				}
				"EOT" {
					puts "Received: $expect_out(buffer)"
					.connect configure -state normal -command connect
					#puts "Modem disconnected"
					exp_continue
				}
				"all ports busy" { 
					log_messages $expect_out(buffer)
					exp_send "~.\r"
				}	
				"NO DIAL TONE" { 
					log_messages $expect_out(buffer)
					.connect configure -state normal -command connect
					puts "NO DIAL TONE"
				}
				"connected" {
					log_messages $expect_out(buffer)
					# dial
					puts "Sending $phone_number"
					puts "******************************\n"
					puts "  Get your DES card ready"
					puts "  Enter your authorization #"
					puts "  Then get read to key in:"
					puts "  1.) Host number"
					puts "  2.) Challenge"
					puts "  Then enter the 'response' into the popup"
					puts "******************************"

					exp_send "atdt $phone_number\r"
					exp_continue
				}

				# auth
				Username: { 
					log_messages $expect_out(buffer)
					exp_send "$username\r" 
					exp_continue
				}
				password: { 
					log_messages $expect_out(buffer)
					exp_send "\r" 
					exp_continue
				}

				# des card challenge/response
				Challenge {
					log_messages $expect_out(buffer)
					exp_continue	
				}

				esponse?  { 
					log_message $expect_out(buffer)
					#puts "expect_out(0,string) = $expect_out(0,string)"
					#puts "expect_out(buffer) = $expect_out(buffer)"

					# pop up entry, display challenge
					#Challenge: 9 6024 Response? 0f68pc72


					if { [winfo exists .des_dialog] != 1 } {  return } 

					set host_challenge [lindex [split $expect_out(buffer)] 1]
					set secret [lindex [split $expect_out(buffer)] 2]

					.des_dialog.challenge_label configure -text \
					"Host: $host_challenge Challenge: $secret"

					puts "\nhost_challenge=$host_challenge"
					puts "secret=$secret"

					des_countdown

					tkwait variable challenge_entered
					if { [info exists des_response] ==1 } {
						puts "Challenge: $des_response"
						exp_send "$des_response\r" 
						set timeout -1
						exp_continue
					} else {
						puts "No challenge entered"
						log_message configure "Disconnected: No challenge entered"
						catch { exec pkill tip }
						sleep 2
						.connect configure -state normal -text "Connect" -command connect 
						return
					}
				}


				"Local command?" {

              if { [string first "Your IP address is" $expect_out(buffer)] != -1 } {
                  puts "\n**** Found IP: $expect_out(buffer) ****\n"
                  foreach line [split $expect_out(buffer) "\r\n"] {
                    puts "PPPD: $line"
                    if { [string first "Your IP" $line] != -1 } {
											set ip_address [lindex [split $line " 	"] 4]	
											set ip_address [string trimright $ip_address "."]
											puts "IP address: $ip_address"
											set mtu [lindex [split $line "  "] 7]
											puts "MTU: $mtu"
											.footer.footer_r configure -text "ppp Connected: $line" -font {times 10 bold} -justify left
                      break
                    }
                  }
              }

								log_message $expect_out(buffer)
								puts "exp_send /usr/bin/pppd debug lock crtscts defaultroute noipdefault noccp novj\r"
								exp_send "/usr/bin/pppd debug lock crtscts defaultroute noipdefault noccp novj\r"

							.connect configure -text "Disconnect" -command {
								catch { exec pkill pppd }
								disconnect "User disconnected"
								.footer.footer_r configure -text "User Disconnected"
							} 
							#puts "Reading ip-up output file"
							read_ip_up
							#ppp_interface serial_port ip_address remote_ip_address port_speed mtu
							.footer.footer_r configure -text \
							"Connected:\n\
							IP address: $ip_address\n\
							MTU: $mtu\n\
							Port Speed: $port_speed\n\
							Remote IP address: $remote_ip_address\n" \
							-font {times 10 bold} -justify left
							post_connect
							monitor_link
							#exp_continue
				}

				">" {
							log_messages $expect_out(buffer)
								exp_send "ppp\r" 
								sleep 1
								exp_send "~C"
								exp_continue

				}

				timeout { 
					log_messages $expect_out(buffer)
					puts "timeout: try again"
					#sleep 2
					#modempool_connect	
				}

				eof {
					log_messages $expect_out(buffer)
					puts "eof: Modem connection closed"
				}
		}

}


proc post_connect { } {

	global post_connect_script

	if { [file exists $post_connect_script] } {
	  puts "exec $post_connect_script"
	  exec $post_connect_script & 
	} 

	return
}


proc pre_connect { } {

	global pre_connect_script 

	if { [file exists $pre_connect_script] } {
	  puts "exec $pre_connect_script" 
	  exec $pre_connect_script & 
	}

	return
}
proc pre_disconnect { } {

	global pre_disconnect_script 

	if { [file exists $pre_disconnect_script] } {
	  puts "exec $pre_disconnect_script"
	  exec $pre_disconnect_script & 
	}

	return
}
proc post_disconnect { } {

	global post_disconnect_script 

	if { [file exists $post_disconnect_script] } {
	  puts "exec $post_disconnect_script"
	  exec $post_disconnect_script & 
	}

	return
}

proc init { } {

	global ppp_settings
	global env
	global ppp_dir
	global pkghome

	puts "Connection Script Env 'USER_ID': $env(USER_ID)"
	puts "Connection Script Env 'CONNECTION_TYPE': $env(CONNECTION_TYPE)"
	set pkghome $env(PKGHOME)


	global manage_resolv
	set manage_resolv "[set pkghome]/manage_resolv"
	#"copy"  
	#"restore"
	#"srcfile=s"
	#"backup_file=s" 

	set ppp_dir "$env(HOME)/.ppptool" 

	global ppp_config_file
	set ppp_config_file "$ppp_dir/ppp_settings"

	global ppp_options_file
	set ppp_options_file "/etc/ppp/options"
	set ppp_options_template "[set pkghome]/options"

	puts "Checking for $ppp_options_file file"
	if { [file exists $ppp_options_file] != 1 } {

			set options_fd ""
			if { [catch { set options_fd \
			[open $ppp_options_file w] } err] != 0 } {

				log_message "Unable to create $ppp_options_file\n"
				.footer.footer_r configure -text "Unable to create $ppp_options_file"
				exit 1
			}

			foreach option { defaultroute noauth noproxyarp } {
				puts $options_fd "$option\n"
			}
			close $options_fd

		if { [file exists $ppp_options_file] != 1 } {
			puts "Create of PPP options file $ppp_options_file failed!"
			exit 1
		}
	}

	# list
	global active_account
	global account_list
	set account_list {}

	# array (account_name,key)
	global accounts

	# connection scripts

  # User configurable scripts in $HOME/.connect
  global pre_connect_script
  global post_connect_script
  global pre_disconnect_script
  global post_disconnect_script

	if [file exists /etc/connect/pre-connect] {
		set pre_connect_script /etc/connect/pre-connect
	} else {
		set pre_connect_script "" 
	}
	if [file exists /etc/connect/post-connect] {
		set post_connect_script /etc/connect/post-connect
	} else {
		set post_connect_script "" 
	}
	if [file exists /etc/connect/pre-disconnect] {
		set pre_disconnect_script /etc/connect/pre-disconnect
	} else {
		set pre_disconnect_script "" 
	}
	if [file exists /etc/connect/post-disconnect] {
		set post_disconnect_script /etc/connect/post-disconnect
	} else {
		set post_disconnect_script "" 
	}
	
	global account_keys
	set account_keys {\
				 name\
				 uid\
				 passwd\
				 number\
				 domain\
				 search \
				 ns1\
				 ns2\
				 authtype\
				 defroute\
				 resolv\
				 status\
				 resolv_file\
	}

	global account_strings
	set account_strings(name) "Account Name:"
	set account_strings(uid) "User ID:"
	set account_strings(passwd) "Password:"
	set account_strings(number) "Phone Number:"
	set account_strings(domain) "DNS Domain Name:"
	set account_strings(search) "DNS Search Domains:"
	set account_strings(ns1) "Account Nameserver #1:"
	set account_strings(ns2) "Account Nameserver #2:"
	set account_strings(authtype) "Authentication Type:"
	set account_strings(defroute) "Default Route:"
	set account_strings(resolv) "Create /etc/resolv.conf:"
	
	global required_keys 
	set required_keys { name uid number authtype }

	global account_file
	set account_file "$ppp_dir/accounts"
	RandomInit [pid]

	if { [string first "sun" [exec arch]] != -1 } { 
		option add *font {palatino 12 bold} 
		option add *font {sun 12 bold} 
	}

	global log_file
	set log_file "$ppp_dir/ppp_log"

	global kill_pppd
	set kill_pppd "[set pkghome]/kill_pppd.sh"


	global ip_up_file
	set ip_up_file "/etc/ppp/ip-up.out"
	if { [file exists $ip_up_file] } { exec rm $ip_up_file }
	global ip_down_file
	set ip_down_file "/etc/ppp/ip-down.out"
	if { [file exists $ip_down_file] } { exec rm $ip_down_file }

		#if_name=$1
		#tty_device=$2
		#speed=$3
		#local_ip=$4
		#remote_ip=$5
		#ipparam=$6
		#DNS1=$DNS1
		#DNS2=$DNS2

	global ip_up_array
	foreach key {
				if_name \
				tty_device \
				speed \
				local_ip \
				remote_ip \
				ipparam \
				DNS1 \
				DNS2 \
				PPPD_PID \
				PPPLOGNAME \
				SPEED \
				IPREMOTE \
				IFNAME \
				PATH \
				PWD \
				SHLVL \
				DEVICE \
				ORIG_UID \
				IPLOCAL } {
		set ip_up_array($key) ""
	}

	load_global
	load_accts
	build_log_win
	build_menus

}

init

