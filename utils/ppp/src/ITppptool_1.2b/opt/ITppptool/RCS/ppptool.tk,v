head	1.10;
access;
symbols;
locks
	pdel:1.10; strict;
comment	@o@;


1.10
date	2003.10.15.23.40.16;	author pdel;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.15.20.28.31;	author pdel;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.15.20.23.46;	author pdel;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.22.23.29.16;	author pdel;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.18.23.36.36;	author pdel;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.18.22.49.47;	author pdel;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.18.22.02.35;	author pdel;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.18.08.43.33;	author pdel;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.17.16.49.45;	author pdel;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.17.08.05.06;	author pdel;	state Exp;
branches;
next	;


desc
@pretty good
@


1.10
log
@hm...
@
text
@#!/bin/sh

#\
	if [ $# -ge 1 -a  "XX$1" = "XX-debug" ]; then
#\
		set -x
#\
	fi

#\
PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/local/bin:/opt/sfw/bin:/usr/ucb:/opt/local/exe:/opt/local/pkgs/tk:/opt/ITTOtcltk/bin:/usr/openwin/bin:/usr/X11R6/bin
#\
export PATH
#\
umask 022

#\
if [ -z "$DISPLAY" ]; then
#\
	echo "`date`: ERROR: DISPLAY environment not set"
#\
	exit 1
#\
fi


#\
OS=`uname -s`
# \
export OS

#\
umask 022
#\
if [ -z "$USER" ] ;then
		#\
		echo "USER -> $USER"
		#\
			echo "no"
		#\
			exit
		#\
		if [ $OS = "SunOS" ]; then
		#\
			if [ -f "/usr/ucb/whoami" ]; then
		#\
				USER_ID=`/usr/ucb/whoami`
		#\
			else
		#\
				USER_ID=`/bin/who am i | awk '{print $1}'`
		#\
			fi
		#\
		elif [ $OS = "Linux" ]; then
		#\
			USER_ID=`whoami`
		#\
		fi
	#\
	export USER_ID
#\
else
	#\
	USER_ID=$USER
	#\
	export USER_ID
#\
fi

#\
echo "USER_ID: $USER_ID"

#\
CONNECTION_TYPE="ppp"
#\
export CONNECTION_TYPE

#\
PPP_HOME=$HOME/.ppptool
#\
export PPP_HOME

#\
if [ ! -d $PPP_HOME ]; then
#\
  mkdir $PPP_HOME >> /tmp/ppp.err.$$ 2>&1 
#\
	chown $USER_ID $PPP_HOME
#\
  if [ $? -ne 0 ]; then
#\
    echo "`date`: Error creating $PPP_HOME" 
#\
    exit
#\
  fi
#\
else
#\
  chmod 755 $PPP_HOME # just in case
#\
fi


# exec link target
#\
if [ -h $0 ]; then
#\
	cd `dirname $0`
#\
	basename=`basename $0`
#\
	link_target=`ls -l $basename | awk '{print $NF}'`
#\
	target=`basename $link_target`
#\
	cd `dirname $link_target`
#\
	echo "pppdir = `pwd`"
#\
	PKGHOME=`pwd`
#\
	export PKGHOME
#\
else
#\
	cd `dirname $0`
#\
	echo "pppdir = `pwd`"
#\
	PKGHOME=`pwd`
#\
	export PKGHOME
#\
	target=`basename $0`
#\
fi


#\
	echo "exec expectk $target  $@@" 
	#\
	if [ $# -ge 1 -a "XX$1" = "XX-debug" ]; then
	#\
	exec expectk $target  "$@@" 
	#\
	else
	#\
	eval exec expectk $target  "$@@"  > /dev/null 2>&1
	#\
	fi

	set procfiles [exec /bin/ls procs] 
	foreach file [set procfiles] {
		if { [file type procs/$file] == "file" } { 
			source "procs/$file" 
		}
	}

	init
@


1.9
log
@ok!
@
text
@d3 6
a8 1
#comment
d29 2
a105 1

a125 3
	exec expectk $target  "$@@" 
	#exec expectk $target  "$@@"  > /dev/null 2>&1
#\
a137 3
	exec expectk $target  "$@@"
	#exec expectk $target  "$@@" > /dev/null 2>&1 
#\
d141 12
a152 565
proc RandomInit { seed } {
        global randomSeed
        set randomSeed $seed
}
proc Random {} {
        global randomSeed
        set randomSeed [expr ($randomSeed*9301 + 49297) % 233280]
        return [expr $randomSeed/double(233280)]
}
proc RandomRange { range } {
        return [expr int([Random]*$range)]
}

proc build_menus { } {

	##############################
	# Create GUI
	##############################
	wm title . "IT PPP Tool"
	. configure -bg lightGray
	menu .menubar -bg lightGray

	# attach it to the main window
	. config -menu .menubar
	global active_account
	global accounts
	global connection_state
	global bulblist
	global bulbs
	global on_color
	global off_color
	global bulb_colors
	global acct_width 30

	#set bulb_colors { yellow red green blue orange violet pink }
	#set bulb_colors { yellow red lightGreen black }
	#set bulb_colors { black green red #000000 }
	set bulb_colors { black red #000000 }

	set on_color [lindex $bulb_colors 0]
	set off_color [lindex $bulb_colors 1] 

	global save_accounts_prompt
	set save_accounts_prompt "false"

	set connection_state "connecting"

	###############################
	# Create more cascade menus
	##############################
	foreach m {File Edit Accounts Help} {

		# same as 'set File [ menu .. ]'
		set $m [menu .menubar.m$m]

		if { $m == "Help" } {
			# figure out how to put on the right side
			#.menubar add cascade -label "     " -menu .menubar.mFill 
			.menubar add cascade -label $m -menu .menubar.m$m 
		} else {
			.menubar add cascade -label $m -menu .menubar.m$m
		}
	}
	##############################
	# Add Menu Items
	##############################
	#puts "\$File = $File"
	$File add command -label "Save Accounts" -command { 
		puts "Save Settings" 
		set save_accounts_prompt "true"
		if { [save_accounts "save"] == 1 } { 
			set save_accounts_prompt "false"
		}
		set save_accounts_prompt "false"
	}
	$File add command -label "View Log" -command { 

			view_log
	
	} 
	$File add command -label Quit -command {

		puts "Quit"
		#puts "close_pppd"
		close_pppd
		global save_accounts_prompt
		# Check if files need saving
		set save_accounts_prompt "true"
		if { [save_accounts "exit"] == 1 } { 
			set save_accounts_prompt "false"
			exit 
		}
		set save_accounts_prompt "false"
		
	}

	$Edit add command  -label "Manage Accounts" -command { 
		puts "Manage Accounts" 
		manage_accounts
	}
	$Edit add command -label "Edit Preferences" -command { 
		puts "Edit Preferences" 
		edit_prefs
	}

	$Help add command -label "About PPP Tool" -command { 
		tk_messageBox -default "ok" -message \
		"IT PPP Tool\nVersion: [exec rpm -q ITppptool]" -title "About PPP Tool" 
	}
	$Help add command -label "PPP Tool Help" -command { help }

	frame .mid -bg lightGray

	label .acct_label -text "Active Account: No Account loaded" -relief groove -bg lightGray
	pack .acct_label -in .mid -fill x
	#label .color -text "Color" -bg white 
	#pack .color -in .mid

	pack .mid  -fill x

	# account window display
	#set no_acct_txt "No Account loaded"
	set no_acct_txt ""
	set acct_width 30
	set pad_val 3 
	set descr_bg lightGreen
	#	 name
	frame .namef  -bg lightGray
	label .namef.name_l -text "Account:" -bg $descr_bg -relief groove 
	label .namef.name_r -text $no_acct_txt -bg lightBlue -width $acct_width -relief groove 
	pack .namef.name_r -side right -pady [expr $pad_val * 2]
	pack .namef.name_l -side right -pady $pad_val
	.namef.name_r configure -anchor w
	#	 uid
	frame .uidf -bg lightGray
	label .uidf.uid_l -text "User ID:"  -bg $descr_bg -relief groove 
	entry .uidf.uid_r -text $no_acct_txt -bg lightYellow -width $acct_width  -relief groove 
	pack .uidf.uid_r -side right -pady $pad_val
	pack .uidf.uid_l -side right -pady $pad_val
	#.uidf.uid_r configure  -anchor w 


	#	 passwd
	frame .passwdf -bg lightGray
	label .passwdf.passwd_l -text "Password: "  -bg $descr_bg -relief groove 
	entry .passwdf.passwd_r -text $no_acct_txt -bg lightYellow -width $acct_width  \
	-relief groove  -show *
	pack .passwdf.passwd_r -side right -pady $pad_val
	pack .passwdf.passwd_l -side right -pady $pad_val
	#.passwdf.passwd_r configure  -anchor w 

	#	 number
	frame .numberf -bg lightGray
	label .numberf.number_l -text "Phone Number:" -bg $descr_bg  -relief groove 
	label .numberf.number_r -text $no_acct_txt -bg lightBlue -width $acct_width  -relief groove 
	pack .numberf.number_r -side right -pady $pad_val
	pack .numberf.number_l -side right -pady $pad_val
	.numberf.number_r configure  -anchor w 
	#	 domain
	#	 ns1
	#	 ns2
	#	 authtype
	frame .authtypef -bg lightGray
	label .authtypef.authtype_l -text "Authentication Type: "  -bg $descr_bg -relief groove 
	label .authtypef.authtype_r -text $no_acct_txt  -bg lightBlue -width $acct_width  -relief groove 
	pack .authtypef.authtype_r -side right -pady $pad_val
	pack .authtypef.authtype_l -side right -pady [expr $pad_val * 2]
	.authtypef.authtype_r configure  -anchor w 


	pack .namef -in .mid -anchor w -fill x
	pack .uidf -in .mid -anchor w -fill x
	pack .passwdf -in .mid -anchor w -fill x
	pack .numberf -in .mid -anchor w -fill x
	pack .authtypef -in .mid -anchor w -fill x

	frame .connect_frame -bg lightGray

	button .connect -text "Connect" -width 20 \
	-state normal -command connect 

	if { [info exists active_account] != 1 } {
		.connect configure -state disabled
	}

	pack .connect -in .connect_frame
	pack .connect_frame -pady 10

	frame .cframe -bg lightGray
	canvas .cframe.can -width 220 -height 20  -bg lightGray

	set x1 5 
	set y1 5
	set x2 15
	set y2 15
	foreach can_oval { 0 1 2 3 4 5 6 7 8 9 10 11 } {
		.cframe.can create oval $x1 $y1 $x2 $y2 -fill red -width 2 -tag "bulb[set can_oval]"
		incr x1 18 
		set x2 [expr $x1 + 10]	
		lappend bulblist "bulb[set can_oval]"
		set bulbs(bulb[set can_oval],color) [lindex $bulb_colors 0]
		#puts "set bulbs(bulb[set can_oval],color) [lindex $bulb_colors 0]"
		#puts "bulbs(bulb[set can_oval],color) == $bulbs(bulb[set can_oval],color)" 
	}
	pack .cframe.can
	pack .cframe 

	frame .modembutton_text
	foreach modem_text { HS AA CD OH RD SD TR MR RS CS SYN FAX } {
		label .modembutton_text._$modem_text -text $modem_text -bg black -fg white -font {times 6}
		pack .modembutton_text._$modem_text -side left
	}
	pack .modembutton_text 

	frame .footer -bg lightGray
	label .footer.footer_l -text "Status:" -relief groove -bg lightGray
	label .footer.footer_r -text "No connection" -relief groove -bg lightGray
	pack .footer.footer_l -side left 
	pack .footer.footer_r -side left -fill x -expand 1
	.footer.footer_r configure -anchor w -justify left	
	pack .footer -anchor s -side bottom -fill x -expand 1 -pady 5

	global menubar_widget
	set menubar_widget .menubar 
	global acct_widget
	set acct_widget $Accounts

	add_accounts
	set_active


}

proc save_prefs { } {

	global ppp_config_file env
	global ppp_settings
	global ppp_settings_saved

	global port_speeds
	global port_speed

	global modem_port
	global flow_control

	global g_modem_port
	global g_flow_control


	set save_needed "false"

	#set ppp_config_file "$ppp_dir/ppp_config"
	#set ppp_settings(init_string) "atz" 
	#set ppp_settings(connect_string) ""
	#set ppp_settings(port_speed) 38400
	#set ppp_settings(flow_control) hardware
	#set ppp_settings(modem_port) /dev/term/b
	#set ppp_settings(ppp_options) "" 

	foreach { key value } [array get ppp_settings] {
		if { $ppp_settings($key) != $ppp_settings_saved($key) } {
			set save_needed "true"
			break
		}
	}

	if { $save_needed == "true" } {

		set config_w [open $ppp_config_file w]

		puts "Saving ppp prefs"
		foreach { key value } [array get ppp_settings] {
			#puts "$key\t$value"
			#puts $config_w "$key\t$value"
			set ppp_settings_saved($key) $value
		}
		puts "ppp Prefs Saved"
		close $config_w
		exec chown $env(USER_ID) $ppp_config_file

	} else {
		puts "No Save needed for PPP Prefs"
	}

}

proc save_accounts {prompt_type} {

	#puts "proc save_accounts"
	global save_accounts_prompt env \
	env accounts saved_accounts ppp_settings \
	ppp_dir
	#set ppp_dir "$env(HOME)/.ppptool" 
	global ppp_config_file
	#set ppp_config_file "$ppp_dir/ppp_settings"
	# list
	global active_account \
	account_list saved_account_list \
	account_keys account_file 

	set save_needed false
	set return_status 1

	# compare account_list to saved_account_list
	if { [llength $account_list] != [llength $saved_account_list] } {
		# something changed
		# write out accounts array
		#puts "llength account_list != llength saved_account_list"
		set save_needed true

	} else {

		# number of accounts equal, but may have different names
		#puts "account_list == saved_account_list"
		foreach account $account_list {
			if { [lsearch $saved_account_list $account] == -1 } {
				#puts "lsearch saved_account_list $account == -1"
				set save_needed true
				break
			} else {
				#puts "lsearch saved_account_list $account != -1"
				continue
			}
		}
	}

	if { $save_needed == "false" } {
		puts "save_needed == false"
		foreach { key value } [array get accounts] {
			puts "Key=$key, value=$value"
			# we should find a match for each
			# if not, something was deleted
			#puts "info exists saved_accounts($key) :?"
			#puts "saved_accounts($key) == $value :?"
			if { [info exists saved_accounts($key)] != 1 } {
				puts "save_needed: info exists saved_accounts($key) != 1"
				set save_needed true
				break
			} elseif { $saved_accounts($key) != $value } {
				puts "480, $saved_accounts($key) != $value, key==$key"
				# don't flag 'status'
				if {  [lindex [split $key  ","] 1] == "status" } {
						set acct_value [string compare  $value "active"]
						puts "acct_value = $acct_value" 
						set saved_key	 [string compare $saved_accounts($key) "active"]
						puts "saved_key	== $saved_key" 
					if { $acct_value == 0 ||  $saved_key == 0 } {
						puts "key $key, $value $value 489"
						#save it and continue without flagging 'save needed'
						# set saved_account to inactive
						#puts "Account list changed, Saving account info .."
						set account_w [open $account_file w] 
						puts "writing to $account_file:"
						foreach account_name $account_list  {
							foreach key [set account_keys] {
								if { [info exists accounts($account_name,$key)] } {
									#puts "$key\t$accounts($account_name,$key)"
									puts $account_w "$key\t$accounts($account_name,$key)"
									# set save_accounts to current values
									set saved_accounts($account_name,$key) $accounts($account_name,$key)
								} else {
									set accounts($account_name,$key) ""
									#puts "$key\t$accounts($account_name,$key)"
									puts $account_w "$key\t$accounts($account_name,$key)"

									# set save_accounts to current values
									set saved_accounts($account_name,$key) "" 

								}
							}
						}
						# set save_account list to current values
						set saved_account_list $account_list
						puts "Wrote account file $account_file"
						close $account_w
						exec chown $env(USER_ID) $account_file
						# write prefs
						save_prefs
						set save_needed "false"
           set return_status 1
					}

				} else {
					#puts "save_needed: saved_accounts($key) != $value"
					set save_needed true
					#break
				}
			}
		}

		foreach { key value } [array get saved_accounts] {
			#puts "Key=$key, value=$value"
			# we should find a match for each
			# if not, something was added
			#puts "info exists accounts($key) :?"
			#puts "accounts($key) = $value :?"
			if { [info exists accounts($key)] != 1 } {
				#puts "save_needed: info exists accounts($key) != 1"
				set save_needed true
				break
			} elseif { $accounts($key) != $value } {
					#puts "save_needed: saved_accounts($key) != $value"
					set save_needed true
					break
			}
				#puts "save_needed: accounts($key) != $value"
				#puts "accounts($key) != $value"
				#set save_needed true
				#break
		}

	}

	if { $save_needed == "true" } {
		if {  $save_accounts_prompt == "true" } {
			if { $prompt_type == "exit" } {
	       set warning_return [tk_messageBox -default yes \
           -type yesnocancel -icon warning \
           -message "To save your changes:\n\n\
                     Click YES to save then exit\n\
                     Click NO to exit without saving\n\
                     Click CANCEL to return to PPP Tool\n" \
           -title "Unsaved Changes"]
			} elseif { $prompt_type == "save" } {

	       set warning_return [tk_messageBox -default ok \
           -type okcancel -icon warning \
           -message "Would you like to save your changes? \n\n\
                     OK to save\n\
                     CANCEL to return to PPP Tool\n" \
           -title "Unsaved Changes"]

			}

        if {"$warning_return" == "yes" || "$warning_return" == "ok"} {

						puts "Account list changed, Saving account info .."
						set account_w [open $account_file w] 
						puts "writing to $account_file:"
						foreach account_name $account_list  {
							foreach key [set account_keys] {
								if { [info exists accounts($account_name,$key)] } {
									#puts "$key\t$accounts($account_name,$key)"
									puts $account_w "$key\t$accounts($account_name,$key)"

									# set save_accounts to current values
									set saved_accounts($account_name,$key) $accounts($account_name,$key)

								} else {
									set accounts($account_name,$key) ""
									#puts "$key\t$accounts($account_name,$key)"
									puts $account_w "$key\t$accounts($account_name,$key)"

									# set save_accounts to current values
									set saved_accounts($account_name,$key) "" 

								}
							}
						}
						# set save_account list to current values
						set saved_account_list $account_list

						puts "Wrote account file $account_file"
						close $account_w
						exec chown $env(USER_ID) $account_file

						# write prefs
						save_prefs
						set save_needed "false"
           set return_status 1

        } elseif {"$warning_return" == "no"} {
           set return_status 1
        } elseif {"$warning_return" == "cancel"} {
           set return_status 0
        }
	
		}

} else {
		puts "No save needed"
	set save_needed "false"
}

	return $return_status

}

proc manage_accounts { } {

		global accounts account_list active_account
		# create win
		# add r/l frames
		# add text & scroll on left
		# add buttons on right
		# add account names to scroll text
		# map buttons to commands
		# create account window w/entry widgets,
		# label/entry for each acct field

	if { [winfo exists .account_manager_win] } { 
		 catch { wm deiconify .account_manager_win }	
		 catch { wm raise .account_manager_win }
		 return
	}

   toplevel .account_manager_win
   wm title .account_manager_win "Account Manager"

   # Two frames, one for a scrolling list of accounts, the other for the buttons

   frame .account_manager_win.account_frame
   pack .account_manager_win.account_frame -side left -padx 1m -pady 1m

   listbox .account_manager_win.account_list -yscrollcommand \
      ".account_manager_win.yscroll_bar set" -xscrollcommand \
			".account_manager_win.xscroll_bar set"
   .account_manager_win.account_list configure -height 10

   scrollbar .account_manager_win.yscroll_bar -command \
      ".account_manager_win.account_list yview" -relief sunken
   .account_manager_win.yscroll_bar set 5 5 0 4

   scrollbar .account_manager_win.xscroll_bar -command \
      ".account_manager_win.account_list xview" -relief sunken \
			-orient horizontal
   .account_manager_win.xscroll_bar set 5 5 0 4

   pack .account_manager_win.yscroll_bar -in .account_manager_win.account_frame \
      -side left -fill y
   pack .account_manager_win.xscroll_bar -in .account_manager_win.account_frame \
      -side bottom -fill x
   pack .account_manager_win.account_list \
      -in .account_manager_win.account_frame -side left 

   bind .account_manager_win.account_list <ButtonRelease-1> {
			if { [string length \
						[.account_manager_win.account_list curselection]] > 0 } {
					set selected_account [list [selection get]]
					#puts "selected_account = $selected_account"
					.account_manager_win.delete_button configure -state normal
					.account_manager_win.edit_button configure -state normal	
					.account_manager_win.select_button configure -state normal
			} else {
					.account_manager_win.delete_button configure -state disabled
					.account_manager_win.edit_button configure -state disabled
					.account_manager_win.select_button configure -state disabled
			}
   }

   bind .account_manager_win.account_list <Double-ButtonPress-1> {
      set active_account $selected_account
			set_account $active_account
      #.account_frame.account_button configure -text $active_account
      destroy .account_manager_win
   }

   foreach account [set account_list] {
		if { $accounts($account,status) != "DELETED" } {
      .account_manager_win.account_list insert end "$accounts($account,name)"
		}
   }

  frame .account_manager_win.button_frame
  pack .account_manager_win.button_frame -padx 1m -pady 1m
d154 4
a157 19
  button .account_manager_win.select_button -text "Make Active" \
      -state disabled -command {
				 #puts "selected_account = $selected_account"
         set active_account $selected_account
         #.account_frame.account_button configure -text $active_account
				 # check if swan or not - if not, enable password
				 set_account $active_account
         #destroy .account_manager_win
      }
  button .account_manager_win.new_button -text New \
      -command {
				puts "Create New Account"
				create_account
			}
  button .account_manager_win.edit_button -text Edit -state disabled \
      -command {
			puts "Edit Account $selected_account"
			edit_account $selected_account
			#.account_manager_win.edit_button configure -state disabled	
a158 28
  button .account_manager_win.delete_button -text Delete -state disabled \
      -command {

			puts "Delete Account"
			set current_sel [.account_manager_win.account_list curselection]
			#puts "current selection: $current_sel: len: [string length $current_sel]"

			if { [string length $current_sel] != 0  } {

				.account_manager_win.account_list delete \
				[.account_manager_win.account_list curselection]

				#.account_manager_win.account_list delete \
				#[.account_manager_win.account_list index $selected_account]

				delete_account_menu $selected_account 
					# if account is active, adjust front panel values
					#puts "Comparing selected account $selected_account to\
					#active account $active_account"
					if { $selected_account == $active_account } {
						set active_account ""
						set_account $active_account
					} 
			} 

			.account_manager_win.edit_button configure -state disabled
			.account_manager_win.select_button configure -state disabled
			.account_manager_win.delete_button configure -state disabled			
a159 549
   button .account_manager_win.close_button -text Close \
      -command {destroy .account_manager_win}
   pack .account_manager_win.select_button .account_manager_win.new_button \
      .account_manager_win.edit_button .account_manager_win.delete_button \
      .account_manager_win.close_button -in .account_manager_win.button_frame \
      -ipadx 2 -ipady 2 -padx 2 -pady 2 -fill x
}



proc delete_account {account_name} {


		#create window
		#name    Account1
		#uid     cbj
		#passwd  bongo
		#number  303 123-4567
		#domain  craig.com
		#ns1     123.456.789.000
		#ns2     987.654.321.000
		#authtype        DES challenge
		#defroute        1

		global accounts
		global account_list
		global account_keys
		global account_strings

		delete_account_menu $account_name

}

proc edit_account {edited_account_name} {


		puts "edit_account"
		#create window
		#name    Account1
		#uid     cbj
		#passwd  bongo
		#number  303 123-4567
		#domain  craig.com
		#ns1     123.456.789.000
		#ns2     987.654.321.000
		#authtype        DES challenge
		#defroute        1
		global edit_account_name
		set edit_account_name $edited_account_name

		global accounts
		global account_list
		global account_keys
		global account_strings
		global authtype
		global defroute
		global resolv
		global active_account
		global required_keys

		#.account_manager_win.account_list selection clear 0 end
		.account_manager_win.edit_button configure -state disabled	
		.account_manager_win.delete_button configure -state disabled
		set top .edit_account

		if { [winfo exists $top] == 1 } { destroy $top }
		toplevel [set top] 

    frame [set top].required_key_frame
    label [set top].required_key_frame.required_key -text "Required Fields indicated by '**'"
    pack [set top].required_key_frame.required_key
    pack [set top].required_key_frame -anchor n
	

		foreach key [set account_keys] {

			if { $key == "status" } { continue }
			if { $key == "resolv_file" } { continue }

			set value $account_strings($key)
			set [set key]_frame [set top].[set key]_frame

			frame [set [set key]_frame]

			#puts "key = $key"
			if { $key == "authtype" } {
				# radio buttons for
				# pap chap challenge card

				radiobutton [set [set key]_frame].[set key]_radio_pap -text \
				"PAP" -variable authtype -value "pap" -width 11

				pack [set [set key]_frame].[set key]_radio_pap -side right

				radiobutton [set [set key]_frame].[set key]_radio_chap -text \
				"CHAP" -variable authtype -value "chap" -width 11
				pack [set [set key]_frame].[set key]_radio_chap -side right

				radiobutton [set [set key]_frame].[set key]_radio_token -text \
				"Token Card" -variable authtype -value "tokencard" -width 11
				pack [set [set key]_frame].[set key]_radio_token -side right

				label [set [set key]_frame].[set key]_label -text "** $value" 
				pack [set [set key]_frame].[set key]_label -side right

				set authtype $accounts($edit_account_name,authtype)

			} elseif { $key == "defroute" } {

				checkbutton [set [set key]_frame].[set key]_check \
				-text "Set default route" -anchor w -onvalue "1" \
				-offvalue "0" -variable defroute -width 42 

				set defroute $accounts($edit_account_name,defroute)

				pack [set [set key]_frame].[set key]_check -side right

				label [set [set key]_frame].[set key]_label -text $value 
				pack [set [set key]_frame].[set key]_label -side right

			} elseif { $key == "resolv" } {

				checkbutton [set [set key]_frame].[set key]_check \
				-text "Create /etc/resolv.conf from DNS settings" -anchor w -onvalue "1" \
				-offvalue "0" -variable resolv -width 42 

				#puts "resolv for account $edit_account_name = \
				#			$accounts($edit_account_name,resolv)"
				set resolv $accounts($edit_account_name,resolv)

				#puts "resolv == $resolv"

				pack [set [set key]_frame].[set key]_check -side right

				label [set [set key]_frame].[set key]_label -text $value 
				pack [set [set key]_frame].[set key]_label -side right

			} else {
				entry [set [set key]_frame].[set key]_entry -width 45

				eval [set [set key]_frame].[set key]_entry insert 0 \
				\"$accounts($edit_account_name,$key)\"

				pack [set [set key]_frame].[set key]_entry -side right

        if { [lsearch $required_keys $key] != -1 } {
          label [set [set key]_frame].[set key]_label -text "** $value"
        } else {
          label [set [set key]_frame].[set key]_label -text $value
        }

				pack [set [set key]_frame].[set key]_label -side right
				pack [set [set key]_frame].[set key]_entry -anchor w
			}

			pack [set [set key]_frame] -fill x -expand 1 -pady 5
		}

		frame [set top].button_frame
		button [set top].button_frame.save -text "Save Edits" -command {

			puts "Save Edits"
			# get all entries
			# Check if 'name' has been changed
			# if so, lreplace old account name from account_list
			# add new account name
			# add to accounts array and account_list
			global edit_account
			global edit_account_name
			global authtype
			global defroute
			global resolv
			global active_account

      # check if name is already taken
      set new_account_name [list [.edit_account.name_frame.name_entry get]]

      if { $new_account_name == "" } {
        tk_messageBox -type ok -icon error -title "Missing Account Name" \
        -message  "Please Enter an Account Name"
        return
      } elseif { [string length $new_account_name] < 1 } {
        tk_messageBox -type ok -icon error -title "Missing Account Name" \
        -message  "Please Enter an Account Name"
        return

      }

			#set new_account_name {}
			set delete_account_flag "true"
			foreach key [set account_keys] {
					# popup for required fields
					if { $key == "status" } { continue }
					if { $key == "resolv_file" } { continue	}
					if { $key == "authtype" } {
            if { [string length $authtype] < 1 } {
              tk_messageBox -type ok -icon error -title \
              "$account_strings($key) Required" -message  \
              "Please Enter $account_strings($key)"
              return
            } else {
              set edit_account($key) $authtype
            }
					} elseif { $key == "defroute" } {
						set edit_account($key) $defroute
					} elseif { $key == "resolv" } {
						set edit_account($key) $resolv
					} else {
								set [set key]_frame .edit_account.[set key]_frame
								set key_value [[set [set key]_frame].[set key]_entry get]
                if { [lsearch $required_keys $key] != -1 && \
															[string length $key_value] < 1 } {
                    tk_messageBox -type ok -icon error -title \
                    "$account_strings($key) Required" -message  \
                    "Please Enter $account_strings($key)"
                    return
								}
								#puts "=====> $key: $key_value" 
								set edit_account($key) $key_value 
								if { $key == "name" } { 
									set new_account_name  [list $key_value] 
									set new_account_string $key_value
									set old_account_string $accounts($edit_account_name,name) 
									set replace_index [lsearch $account_list $edit_account_name]
									# Check if name has changed
									if { $edit_account_name != $new_account_name } {
										#puts "replacing $edit_account_name with $new_account_name\
										#at index $replace_index"
										set account_list [lreplace $account_list $replace_index \
										$replace_index  $new_account_name]
										#puts "account_list == $account_list"

										# save resolv_file name from old account
										set edit_account(resolv_file) \
										$accounts($edit_account_name,resolv_file)
										set edit_account(status) \
										$accounts($edit_account_name,status)

									} else {
										# name has not changed, don't delete from accounts
										# in delete_account_menu
										set delete_account_flag "false"
									}
								}


					}
						
			}




			if { $delete_account_flag == "false" } {

				foreach { key value } [array get edit_account] {
					#puts "accounts($new_account_name,$key) = $value" 
					set accounts($new_account_name,$key) $value 
				}
				set_account $new_account_name

				# write resolv file in case changed
				write_resolv_file $accounts($new_account_name,name)	

			} else {
					
				# add to accounts
				#puts "account name: $new_account_name"
				#puts "account string: $new_account_string"
				set accounts($new_account_name,name) $new_account_string

				foreach { key value } [array get edit_account] {
					#puts "accounts($new_account_name,$key) = $value" 
					set accounts($new_account_name,$key) $value 
				}
				# write resolv file in case changed
				write_resolv_file $accounts($new_account_name,name)	

				# delete old account	
				set deleted_index [delete_account_menu $edit_account_name] 
				# add to Accounts menu and acct manager
				add_account_menu $new_account_name $deleted_index

				# remove from account list
				set account_box_items [.account_manager_win.account_list get 0 end]
				foreach item $account_box_items {
					if { $item == $old_account_string } {
						#puts "deleting $item from account list at index \
						#[lsearch $account_box_items $item]"
						.account_manager_win.account_list delete \
						[lsearch $account_box_items $item]
					}
				}
				
				.account_manager_win.account_list insert $replace_index "$accounts($new_account_name,name)"

				# if account is active, adjust front panel values
				#puts "Comparing edited account $edit_account_name to\
				#active account $active_account"
				if { $edit_account_name == $active_account } {
					set active_account $new_account_name
					set_account $new_account_name
				}
				set edit_account_name $new_account_name
			}

				.account_manager_win.edit_button configure -state normal	
				.account_manager_win.delete_button configure -state normal
				destroy .edit_account 
		}

		button [set top].button_frame.close -text "Close" -command {
				.account_manager_win.edit_button configure -state normal	
				.account_manager_win.delete_button configure -state normal
				destroy .edit_account 
		}

		pack .edit_account.button_frame.close -side right 
		pack .edit_account.button_frame.save -side left 
		pack .edit_account.button_frame -side bottom -pady 10 

}

proc create_account { } {
		#create window
		#name    Account1
		#uid     cbj
		#passwd  bongo
		#number  303 123-4567
		#domain  craig.com
		#ns1     123.456.789.000
		#ns2     987.654.321.000
		#authtype        DES challenge
		#defroute        1

		global accounts
		global account_list
		global account_keys
		global account_strings
		global create_authtype
		global create_defroute
		global create_resolv

		set top .new_account
		toplevel [set top] 
		global required_keys

		frame [set top].required_key_frame
		label [set top].required_key_frame.required_key -text "Required Fields indicated by '**'"
		pack [set top].required_key_frame.required_key
		pack [set top].required_key_frame -anchor n

		foreach key [set account_keys] {

			if { $key == "status" } { continue }
			if { $key == "resolv_file" } { continue }

			set value $account_strings($key)
			set [set key]_frame [set top].[set key]_frame

			frame [set [set key]_frame]

			#puts "key = $key"
			if { $key == "authtype" } {
				# radio buttons for
				# pap chap challenge card

				radiobutton [set [set key]_frame].[set key]_radio_pap -text \
				"PAP" -variable create_authtype -value "pap" -width 12

				pack [set [set key]_frame].[set key]_radio_pap -side right

				radiobutton [set [set key]_frame].[set key]_radio_chap -text \
				"CHAP" -variable create_authtype -value "chap" -width 12
				pack [set [set key]_frame].[set key]_radio_chap -side right

				radiobutton [set [set key]_frame].[set key]_radio_token -text \
				"Token Card" -variable create_authtype -value "tokencard" -width 12
				pack [set [set key]_frame].[set key]_radio_token -side right

				label [set [set key]_frame].[set key]_label -text "** $value" 
				pack [set [set key]_frame].[set key]_label -side right
				set create_authtype ""

			} elseif { $key == "defroute" } {
				set create_defroute 0
				checkbutton [set [set key]_frame].[set key]_check \
				-text "Set default route" -anchor w -onvalue "1" \
				-offvalue "0" -variable create_defroute -width 42 

				pack [set [set key]_frame].[set key]_check -side right

				label [set [set key]_frame].[set key]_label -text $value 
				pack [set [set key]_frame].[set key]_label -side right

			} elseif { $key == "resolv" } {

				checkbutton [set [set key]_frame].[set key]_check \
				-text "Create /etc/resolv.conf from DNS settings" -anchor w -onvalue "1" \
				-offvalue "0" -variable create_resolv -width 42 

				pack [set [set key]_frame].[set key]_check -side right

				label [set [set key]_frame].[set key]_label -text $value 
				pack [set [set key]_frame].[set key]_label -side right

			} else {
				entry [set [set key]_frame].[set key]_entry -width 45
				pack [set [set key]_frame].[set key]_entry -side right
				if { [lsearch $required_keys $key] != -1 } {
					label [set [set key]_frame].[set key]_label -text "** $value" 
				} else {
					label [set [set key]_frame].[set key]_label -text $value 
				}
				pack [set [set key]_frame].[set key]_label -side right
				pack [set [set key]_frame].[set key]_entry -anchor w
			}

			pack [set [set key]_frame] -fill x -expand 1 -pady 5
		}

		frame [set top].button_frame

		button [set top].button_frame.save -text "Create Account" -command {

			# get all entries
			# add to accounts array and account_list
			global new_account
			global create_authtype
			global create_defroute
			global create_resolv
			
			# check if name is already taken
			set new_account_name [list [.new_account.name_frame.name_entry get]]

			if { [lsearch $account_list $new_account_name] != -1 } {
				tk_messageBox -type ok -icon error -title "Duplicate Account Name" \
				-message  "Account name $new_account_name already exists"
				return
			} elseif { $new_account_name == "" } {
				tk_messageBox -type ok -icon error -title "Missing Account Name" \
				-message  "Please Enter an Account Name"
				return

			} elseif { [string length $new_account_name] < 1 } {
				tk_messageBox -type ok -icon error -title "Missing Account Name" \
				-message  "Please Enter an Account Name"
				return

			}


			set account_name {}
			foreach key [set account_keys] {
					#puts "-------> Key $key" 

					if { $key == "status" } { continue }
					if { $key == "resolv_file" } { continue }

					# get checkbuttons separate from entry boxes
					if { $key == "authtype" } {
						
						if { [string length $create_authtype] < 1 } {
							tk_messageBox -type ok -icon error -title \
							"$account_strings($key) Required" -message  \
							"Please Enter $account_strings($key)"
							return
						} else {
							set new_account($key) $create_authtype 
						}

					} elseif { $key == "defroute" } {
						set new_account($key) $create_defroute
					} elseif { $key == "resolv" } {
						set new_account($key) $create_resolv
					} else {

								# entry boxes
								set [set key]_frame .new_account.[set key]_frame
								set key_value [[set [set key]_frame].[set key]_entry get]
								#puts "----> key: $key key_value: $key_value" 
								set new_account($key) $key_value 

								# required fields
								#account_strings(name) "Account Name:"
								#account_strings(uid) "User ID:"
								#account_strings(passwd) "Password:"
								#account_strings(number) "Phone Number:"
								#account_strings(domain) "DNS Domain Name:"
								#account_strings(ns1) "Account Nameserver #1:"
								#account_strings(ns2) "Account Nameserver #2:"
								#account_strings(authtype) "Authentication Type:"
								#account_strings(defroute) "Default Route:"

								if { $key == "name" } { 
									set account_name  [list $key_value] 
									set account_string $key_value
								}


								if { [lsearch $required_keys $key] != -1 && [string length $key_value] < 1 } {
										
										tk_messageBox -type ok -icon error -title \
										"$account_strings($key) Required" -message  \
										"Please Enter $account_strings($key)"
										return

								}

								
					}
						
			}
					lappend account_list $account_name
					
					# add to accounts
					#puts "account name: $account_name"
					#puts "account string: $account_string"
					set accounts($account_name,name) $account_string

					foreach { key value } [array get new_account] {
						#puts "accounts($account_name,$key) = $value" 
						set accounts($account_name,$key) $value 
					}

					# create resolv.conf name for this account
					set resolv_name "[set ppp_dir]/resolv.conf.[RandomRange 1000]" 
					set accounts($account_name,resolv_file) $resolv_name
					#puts "resolv.conf file is $accounts($account_name,resolv_file)"
					# write a resolv.conf file to the file
					write_resolv_file $accounts($account_name,name)	

					# set status
					set accounts($account_name,status) inactive 

					# add to Accounts menu and acct manager
					add_account_menu $account_name "END"
					.account_manager_win.account_list insert end "$accounts($account_name,name)"

				destroy .new_account 
		}

		button [set top].button_frame.close -text "Close" -command {
				destroy .new_account 
		}

		pack .new_account.button_frame.close -side right 
		pack .new_account.button_frame.save -side left 
		pack .new_account.button_frame -side bottom -pady 10 
d161 1
a161 2432
}

proc write_resolv_file { account_name } {

	puts "write_resolv_file"
	global accounts	env
	# get account	
	set list_name [list $account_name]
	set resolv_file $accounts($list_name,resolv_file)
	set domain $accounts($list_name,domain)
	set search $accounts($list_name,search)
	set ns1 $accounts($list_name,ns1)
	set ns2 $accounts($list_name,ns2)

	#puts "Opening resolv_file $resolv_file"
	if { [catch { set resolv_fd [open $resolv_file w] } err] != 0 } {
		puts "Unable to create $resolv_file: $err"
		return -1
	}
	puts $resolv_fd "# resolv.conf file generated by ppptool"
	puts $resolv_fd "domain $domain"
	if { [string length $search] < 1 } {
		if { [string length $domain] > 0 } {
			puts $resolv_fd "search $domain"
		}
	} else {
		puts $resolv_fd "search $search"
	}
	puts $resolv_fd "nameserver $ns1"
	puts $resolv_fd "nameserver $ns2"
	close $resolv_fd
	exec chown $env(USER_ID) $resolv_file
	puts "Created resolv_file $resolv_file"

	return 0

}


proc blink_single {bulb } {

	global connection_state
	global incr_value
	global bulblist
	global on_color
	global off_color
	global bulb_colors 
	global after_interval
	global bulbs

	set after_interval [RandomRange 500 ] 

		if { [lsearch $bulb_colors $bulbs($bulb,color)] == [expr [llength $bulb_colors] - 1] } {
			set bulbs($bulb,color) [lindex $bulb_colors 0]
		} else {
			set bulbs($bulb,color) [lindex $bulb_colors [expr [lsearch $bulb_colors $bulbs($bulb,color)]  + 1]]
		}
		if { $after_interval > 250 } {
			.cframe.can itemconfigure $bulb -fill $bulbs($bulb,color) 
		}

		if { $connection_state != "connecting" } {
			puts "blink_single: .cframe.can itemconfigure all -fill black"
			.cframe.can itemconfigure all -fill black 
			#puts "after $after_interval blink_single $bulb"
			#after $after_interval blink_single $bulb
		} else {
			#puts "blink_single: after $after_interval blink_single $bulb"
				if { $bulb == "bulb0" || $bulb == "bulb3" } {
					puts "blink_single: .cframe.can itemconfigure $bulb -fill green" 
					.cframe.can itemconfigure $bulb -fill green 
				} elseif  { $bulb == "bulb10" } {
					puts "blink_single: .cframe.can itemconfigure $bulb -fill yellow" 
					.cframe.can itemconfigure $bulb -fill yellow 
				}
			after $after_interval blink_single $bulb
		}
}


proc init_blinking_bulbs { } {

	puts "init_blinking_bulbs"
	global connection_state
	global incr_value
	global bulblist
	global bulbs
	global on_color
	global off_color
	global bulb_colors 
	global after_interval

	# set different intervals

	foreach bulb $bulblist {

		#puts "bulb $bulb"
		set after_interval [RandomRange 1000] 

		if { [lsearch $bulb_colors $bulbs($bulb,color)] == [expr [llength $bulb_colors] - 1] } {
			puts "bulbs($bulb,color) = $bulbs($bulb,color)"
			set bulbs($bulb,color) [lindex $bulb_colors 0]
		} else {
			set bulbs($bulb,color) [lindex $bulb_colors [expr [lsearch $bulb_colors $on_color]  + 1]]
		}

			if { $bulb != "bulb0" && $bulb != "bulb3" && $bulb != "bulb10"  } {	
				puts "init_blinking: .cframe.can itemconfigure $bulb -fill $bulbs($bulb,color)" 
				.cframe.can itemconfigure $bulb -fill $bulbs($bulb,color) 
				#after $after_interval blink_single $bulb
				blink_single $bulb
			} else {
				puts "init_blinking Constant: .cframe.can itemconfigure $bulb -fill green" 
				if { $bulb == "bulb0" || $bulb == "bulb3" } {
					puts ".cframe.can itemconfigure $bulb -fill green" 
					.cframe.can itemconfigure $bulb -fill green 
				} else {
					puts ".cframe.can itemconfigure $bulb -fill yellow" 
					.cframe.can itemconfigure $bulb -fill yellow 
				}
			}
	}
}


proc edit_prefs { } {

	global ppp_settings
	global ppp_settings_saved
	global modem_port
	global flow_control

	global g_modem_port
	global g_flow_control

	global port_speeds
	global port_speed
	puts "Modem port = $ppp_settings(modem_port)"

	if { [winfo exists .prefs] } { 
		 catch { wm deiconify .prefs }	
		 catch { wm raise .prefs }
		 return
	} 
		toplevel .prefs

		frame .prefs.pref_frame


			## Menubutton items ##

		foreach ppp_setting { modem_port flow_control port_speed } {

				set button_descr "[lindex [split $ppp_setting '_'] 0] [lindex [split $ppp_setting '_'] 1]"
				#set ppp_settings(modem_port) /dev/term/b
				frame .prefs.pref_frame.[set ppp_setting]_frame

				if { [info exists ppp_settings($ppp_setting)] == 1 } {
					#puts "$ppp_setting = $ppp_settings($ppp_setting)"
					set [set ppp_setting]_button_text $ppp_settings($ppp_setting)
				} else {
					#puts "$ppp_setting = $ppp_settings($ppp_setting)"
					set [set ppp_setting]_button_text "Select $button_descr" 
				}
				menubutton .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting] \
				-text [set [set ppp_setting]_button_text] \
				-menu .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting].menu \
				-relief raised  -width 25 

				pack .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting] -side right 
				label .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_label -text $button_descr
				pack .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_label -side right
				#.prefs.pref_frame.[set ppp_setting]_frame.modem_port configure -anchor w	


				pack .prefs.pref_frame.[set ppp_setting]_frame -fill x -expand 1 -pady 2
				eval { set [set ppp_setting]_menu \
				[menu .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting].menu -tearoff 0] }

				if { $ppp_setting == "modem_port" } {
					set modem_ports {}
					foreach modem_port { 0 1 2 3 4 5 6 7 8 9 } { 
						if { [file exists "/dev/ttyS$modem_port"] == 1 } {
							lappend modem_ports "/dev/ttyS$modem_port"
						}
					}
					if { [file exists /dev/modem] == 1 } {
						lappend modem_ports /dev/modem
					}

					foreach modem_port $modem_ports {
							#set modem_port "/dev/[set modem_port]"
							#puts "[set ppp_setting]_menu add command -label $modem_port -command"
							#puts "ppp_settings: [array names ppp_settings]"

							eval { [set [set ppp_setting]_menu] add radio -label $modem_port -variable modem_port \
											-value $modem_port -command {
												.prefs.pref_frame.modem_port_frame.modem_port configure -text $modem_port
											}
							}
					}
					set modem_port $ppp_settings(modem_port)
				} elseif { $ppp_setting == "flow_control" } {

					foreach flow_control { hardware software none } {
							#puts "[set ppp_setting]_menu add command -label $flow_control -command"
							#puts "ppp_settings: [array names ppp_settings]"

							eval { [set [set ppp_setting]_menu] add radio -label $flow_control -variable \
											flow_control  -value $flow_control -command {
												.prefs.pref_frame.flow_control_frame.flow_control \
												configure -text $flow_control
											}
							}
					}
					set flow_control $ppp_settings(flow_control)

		} elseif { $ppp_setting == "port_speed" } {

				#port_speeds { 38400 57600 115200 230400 } 

				foreach port_speed  $port_speeds  {
					#puts "[set ppp_setting]_menu add command -label $port_speed -command"
					#puts "ppp_settings: [array names ppp_settings]"

							eval { [set [set ppp_setting]_menu] add radio -label $port_speed \
							-variable port_speed  -value $port_speed -command {
												.prefs.pref_frame.port_speed_frame.port_speed \
												configure -text $port_speed
											}
							}
				}
				set port_speed $ppp_settings(port_speed)

		}
	}

			#### Entry items ###

			set last_width 0 
			foreach ppp_setting { init_string connect_string ppp_options } {
				#puts "ppp_setting $ppp_setting"
				set entry_width [string length $ppp_settings($ppp_setting)]
				if { $entry_width < 20 } { set entry_width 25 }
				if { $entry_width > $last_width } { set last_width $entry_width }
			}
				if { $entry_width < $last_width } { set entry_width [expr $last_width + 5] }
				.prefs.pref_frame.modem_port_frame.modem_port configure -width $entry_width
				.prefs.pref_frame.flow_control_frame.flow_control configure -width $entry_width
			

			foreach ppp_setting { init_string connect_string ppp_options } {

				frame .prefs.pref_frame.[set ppp_setting]_frame
				label .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_label -text $ppp_setting 
				entry .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_entry -width $entry_width
				.prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_entry insert 0 $ppp_settings($ppp_setting)

				pack .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_entry -side right 
				pack .prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_label  -side right
				pack .prefs.pref_frame.[set ppp_setting]_frame -fill x -expand 1 -pady 2
			}



			#set ppp_settings(port_speed) 38400
			#set ppp_settings(flow_control) hardware

			#set ppp_settings(init_string) "atz" 
			#set ppp_settings(connect_string) ""
			#set ppp_settings(ppp_options) "" 

			pack .prefs.pref_frame -pady 2

		frame .prefs.prefbuttons
		button .prefs.prefbuttons.prefs_save -text "Save" -command {

			
					global ppp_settings
					global ppp_settings_saved
					global modem_port
					global flow_control

					global g_modem_port
					global g_flow_control

					global port_speeds
					global port_speed

			puts "Save Prefs" 
			foreach ppp_setting { init_string connect_string ppp_options } {
				set ppp_settings($ppp_setting) \
				[.prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_entry get]
				#puts "saved ppp_setting $ppp_setting as \
				#[.prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_entry get]"
			}
			foreach ppp_setting { modem_port flow_control port_speed } {
				#puts "port_speed == $port_speed"
				#puts "$ppp_setting = [set [set ppp_setting]]"
				set ppp_settings($ppp_setting) [set [set ppp_setting]] 
				#puts "saved ppp_setting $ppp_setting as $ppp_settings($ppp_setting)" 
			}
			
			save_prefs
			## write_global #
			#destroy .prefs
			wm withdraw .prefs
		}

		button .prefs.prefbuttons.prefs_close -text "Close" -command { wm withdraw .prefs }
		pack .prefs.prefbuttons.prefs_save -side left
		pack .prefs.prefbuttons.prefs_close -side right
		pack .prefs.prefbuttons -side bottom -pady 5
	
}

proc log_message { message } {

	catch { [.log_win.log_text insert end $message] }
	catch [.log_win.log_text yview end]

}

proc view_log { } {
	catch { [wm deiconify .log_win] }
}

proc build_log_win { } {

	global accounts
	global active_account


	toplevel .log_win 
	wm title .log_win "PPP Log"
	wm withdraw .log_win

	frame .log_win.log_frame -relief flat
	text .log_win.log_text -relief sunken -borderwidth 2 \
	-yscrollcommand { .log_win.scroll_y set} \
	-height 20 -width 65 -setgrid true
	scrollbar .log_win.scroll_y -command ".log_win.log_text yview"
	pack .log_win.log_text -in .log_win.log_frame -side left -pady 1m -fill both
	pack .log_win.scroll_y -in .log_win.log_frame -side right -fill y

	frame .log_win.button_frame -relief flat
	button .log_win.close_button -text "Close" -command {\
		wm withdraw .log_win
	}

	pack .log_win.close_button -side bottom -in .log_win.button_frame \
	-ipadx 2 -padx 2

	pack .log_win.log_frame .log_win.button_frame -side top



}

proc add_accounts { } {

	global menubar_widget
	global acct_widget
	global color_array
	global account_list
	global accounts

	foreach account $account_list {
		add_account_menu $account "END"
	}
}

proc set_active { } {

	global active_account
	global accounts
	global account_list

	foreach acct $account_list {

		if { [info exists accounts($acct,status)] } {
			if { $accounts($acct,status) == "active" } {
				#puts "Setting account $acct to 'active' status"
				set active_account $acct
				set_account $acct
			}
		} else {
				#puts "Setting account $acct to 'inactive' status"
				set accounts($acct,status) ""
		}

	}

}

proc set_account {value } {

	# display active account 

	global menubar_widget
	global active_account
	global color_array
	global accounts
	global account_list
	global acct_width

	if { [string length $active_account] > 0 && \
			$accounts($active_account,status) == "DELETED" } {

		.acct_label configure -text "Active Account:"
		.namef.name_r configure -text ""

		.uidf.uid_r delete 0 end 
		.uidf.uid_r configure -state disabled 
		.passwdf.passwd_r configure -state disabled 
		.numberf.number_r configure -text ""
		.authtypef.authtype_r configure -text ""
		.connect configure -state disabled
		return
	}

	if { [string length $active_account] > 0 } {

		.acct_label configure -text \
		"Active Account: $accounts($active_account,name)" \
		-width [expr \
		[string length "Active Account: $accounts($active_account,name)"] + 10]

		set namelabel_width [expr [string length $accounts($active_account,name)] + 5]

		if { [.namef.name_r cget -width] < $namelabel_width } { 
			.namef.name_r configure -width $namelabel_width 
			.uidf.uid_r configure -width $namelabel_width
			.passwdf.passwd_r configure -width $namelabel_width
			.numberf.number_r configure -width $namelabel_width
			.authtypef.authtype_r configure -width $namelabel_width
		} else {
			.namef.name_r configure -width $acct_width
			.uidf.uid_r configure -width $acct_width
			.passwdf.passwd_r configure -width $acct_width 
			.numberf.number_r configure -width $acct_width
			.authtypef.authtype_r configure -width $acct_width
		}

		.namef.name_r configure -text "$accounts($active_account,name)" 


		.uidf.uid_r delete 0 end 
		.uidf.uid_r insert 0 "$accounts($active_account,uid)"

		if { $accounts($active_account,authtype) == "tokencard" } {
			.uidf.uid_r configure -state normal 
			.passwdf.passwd_r delete 0 end 
			.passwdf.passwd_r configure -state disabled 
		} else {
			.uidf.uid_r configure -state normal 
			.passwdf.passwd_r configure -state normal 
			.passwdf.passwd_r delete 0 end 
			.passwdf.passwd_r insert 0 "$accounts($active_account,passwd)" 
		}

		.numberf.number_r configure -text "$accounts($active_account,number)"

		.authtypef.authtype_r configure -text "$accounts($active_account,authtype)"

		if { [info exists active_account] } {
			.connect configure -state normal
		} else {
			.connect configure -state disabled
		}
	} else {
		.acct_label configure -text "Active Account:"
		.namef.name_r configure -text ""

		.uidf.uid_r delete 0 end 
		.passwdf.passwd_r delete 0 end 
		.numberf.number_r configure -text ""
		.authtypef.authtype_r configure -text ""
		.connect configure -state disabled
	}

	# reset active key
	foreach acct $account_list {

		if { $acct == $active_account } {
			#puts "Setting account $acct to 'active' status"
			set accounts($active_account,status) "active"
		} else {
			#puts "Setting account $acct to 'inactive' status"
			set accounts($acct,status) ""
		}
	}
}

proc set_menu {value } {
	global menubar_widget
	global active_account
	$menubar_widget entryconfigure 3 -label $value
}

proc add_account_menu {name index} {

	global menubar_widget
	global acct_widget
	global active_account
	global accounts

	if { $index != "END" } {
		$acct_widget insert $index radio  -variable active_account \
		-value $name -label $accounts($name,name) -command { set_account $active_account }
	} else {
		$acct_widget add radio  -variable active_account \
		-value $name -label $accounts($name,name) -command { set_account $active_account }
	}
	
	# save menu position

}


proc delete_account_menu {name} {

	global menubar_widget
	global acct_widget
	global active_account
	global accounts
	global account_list
	global account_keys
	global saved_accounts


	# find where it is
	# number of indexes should correspond to llength $account_list
	#puts "Looking for menu entry $name"
	set index [$acct_widget index $accounts($name,name)]

	# delete accounts entry
	foreach key $account_keys {
		set accounts($name,$key) DELETED 
		set saved_accounts($name,$key) DELETED 
	}

	# delete account_list entry
	set account_list [lreplace $account_list \
	[lsearch $account_list $name] \
	[lsearch $account_list $name]]

	#puts "Deleting index $name at index $index"
	$acct_widget delete $index

	#puts "account_list now contains: $account_list"
	#puts "accounts now contains:"
	#puts [array get accounts]

	set saved_account_list $account_list
	
	# save menu position
	# return index
	return $index

}

# load global settings
proc load_global { } {

	global ppp_dir env
	global ppp_config_file
	global ppp_settings
	global ppp_settings_saved
	global port_speeds
	set port_speeds { 38400 57600 115200 230400 } 

	global g_modem_port
	global g_flow_control

	set ppp_settings(init_string) "atz" 
	set ppp_settings(connect_string) ""
	set ppp_settings(port_speed) [lindex $port_speeds 0] 
	set ppp_settings(flow_control) hardware
	set ppp_settings(modem_port) /dev/ttyS0
	set ppp_settings(ppp_options) "" 

  set ppp_settings_saved(init_string) "atz" 
  set ppp_settings_saved(connect_string) ""
  set ppp_settings_saved(port_speed) [lindex $port_speeds 0] 
  set ppp_settings_saved(flow_control) hardware
  set ppp_settings_saved(modem_port) /dev/ttyS0
  set ppp_settings_saved(ppp_options) "" 


	set ppp_config_file "$ppp_dir/ppp_settings"

	if { [file exists  $ppp_config_file] != 1 } {
		puts "Creating $ppp_config_file"
		set global_fd [open $ppp_config_file w]
		# put in defaults
		foreach key [array names ppp_settings] {
			puts $global_fd "$key\t$ppp_settings($key)"
		}
		close $global_fd
		#puts "exec chown $env(USER_ID) $ppp_config_file"
		exec chown $env(USER_ID) $ppp_config_file

	} else {
		#puts "Reading $ppp_config_file"
		set ppp_fd [open $ppp_config_file r]
		while { [gets $ppp_fd line] != -1 } {
			set split_line [split $line "\t"]
			set ppp_settings([lindex $split_line 0]) [lindex $split_line 1]
			set ppp_settings_saved([lindex $split_line 0]) [lindex $split_line 1]
			#puts "set ppp_settings([lindex $split_line 0]) [lindex $split_line 1]"
		}
	}

	set g_modem_port ppp_settings(modem_port)
	set g_flow_control ppp_settings(flow_control)

	#pppopts
	# init_string
	# connect_string
	# port_speed
	# flow_control
	# modem_port

}

proc load_current_accts { } {

	global env
	global ppp_dir

	# list
	global saved_account_list

	# array (saved_account_name,key)
	global saved_accounts

	# account file names
	global saved_account_file

	global account_keys

	set saved_account_name ""

	if { [file exists $account_file] } {

		set saved_account_fd [open $account_file r]

				# parse into acct_array
				for { set i 0 } { [gets $saved_account_fd line] != -1 } {incr i} {

					if { [string length $line] < 1 } { continue }
					set field [split $line "\t"]
					set key [lindex $field 0]
					string trim $key
					#puts "Key=$key"
					set value [lindex $field 1]
					#puts "Value=$value"

					# check key
					if { [lsearch $saved_account_keys $key] == -1 } {
						#puts "Invalid key $key found in account file $acct"
						continue
					}

					# make sure account name is same as file prefix
					if { $key == "name" } {
						# New account
						#puts "Account $value"
						set saved_account_name $value
						lappend saved_account_list $value
					}
					#puts "Adding key '$key' value '$value' to saved_accounts"
					set saved_accounts($saved_account_name,$key) $value
				}

				close $saved_account_fd
	} 
			# done
			#puts "Loaded saved_accounts"

}


proc load_accts { } {

	global env
	global ppp_dir
	# list
	global account_list
	global saved_account_list
	set saved_account_list {}
	# array (account_name,key)
	global accounts
	global saved_accounts
	# account file names
	global account_file
	global account_keys

	global active_account

	set account_name ""
	set previous_name ""

	if { [file exists $account_file] } {

		set account_fd [open $account_file r]

				# parse into acct_array
				for { set i 0 } { [gets $account_fd line] != -1 } {incr i} {

					if { [string length $line] < 1 } { continue }
					set field [split $line "\t"]
					set key [lindex $field 0]
					string trim $key
					#puts "Key=$key"
					set value [lindex $field 1]
					#puts "Value=$value"

					# check key
					if { [lsearch $account_keys $key] == -1 } {
						#puts "Invalid key $key found in account file accounts"
						continue
					}

					# make sure account name is same as file prefix
					if { $key == "name" } {
						# New account
						# first check last account
						#puts "Account $value"
						set account_name [list $value]
						set previous_name $account_name 
						#puts "Adding account name $account_name to account_list"
						lappend account_list $account_name
						#puts "Adding account name $account_name to saved_account_list"
						lappend saved_account_list $account_name
							#puts "Adding key '$key' value '$value' to accounts"
							set accounts($account_name,$key) $value
							#puts "Adding key '$key' value '$value' to saved_accounts"
							set saved_accounts($account_name,$key) $value
					} else {
							#puts "Adding key '$key' value '$value' to accounts"
							set accounts($account_name,$key) $value
							#puts "Adding key '$key' value '$value' to saved_accounts"
							set saved_accounts($account_name,$key) $value
					}
				}
				close $account_fd

				# verify
				#puts "verifying accounts"
				foreach account $account_list {
							foreach key $account_keys {
								#puts "key $key"
								#puts "account $account"
								if { [info exists accounts($account,$key)] == 0 } {
										#puts "key $key not found in accounts file"
										#puts "set accounts($account,$key)"
										set accounts($account,$key) ""
								}
							}

				}


				# check for resolv_file entries?
	} 
			# done
			puts "Loaded accounts"

}
#======================================================================
# Close the PPP tunnel. Log any messages.
#======================================================================

proc close_ppp_tunnel {} {
  #puts "proc close_ppp_tunnel {} "
  global network_interface message spawn_id  port_id
  global tip_id connection_type global pppd_pid pppd_id

  #set spawn_id $tip_id
	#puts "spawn_id = $spawn_id"

	if { [info exists connection_type] != 1 } { return }

  catch {
		if { $connection_type == "pppd" } {
			exp_send -i $pppd_id ""
			exec pkill pppd
			#puts "Sending kill -TERM $pppd_pid"
			catch { exec kill -TERM $pppd_pid }
		} else {
			exp_send "~."
			expect "[EOT]"
		}

		#close $tip_id
		#close $spawn_id
		#set kill_pid [exp_pid -i $spawn_id] 
		#puts "Sending kill to pid $kill_pid"
		#exec kill -TERM $kill_pid
	}
  
	 #puts "close_ppp_tunnel done"
}


proc log_messages {message} {

  #puts "proc log_messages {message} "

   global log_file env
   regsub "\r" $message "\n" newline_message 
   set message $newline_message

  if { [info exists message] == 1 } {
     .log_win.log_text insert end "$message\n"
     .log_win.log_text yview end

     set fd [open $log_file a]
     if {$fd == ""} {
        return 0
     }
    puts $fd "$message\n"
    close $fd
		exec chown $env(USER_ID) $log_file
  }
}


proc des_countdown { } {

	global seconds_remaining

	if { [winfo exists .des_dialog] != 1 } {  return } 

	if { $seconds_remaining == "null" } {
		

	} elseif { $seconds_remaining == 0 } {
		.des_dialog.time_remaining configure -text "Challenge Entry Interval Expired!"
		.footer.footer_r configure -text "Challenge Entry Interval Expired!\n"
		.connect configure -state disabled
		sleep 30
		#wm withdraw .des_dialog
		destroy .des_dialog
		disconnect "Challenge Entry Interval Expired"
		return -1
	} else {
		.des_dialog.time_remaining configure -text "Seconds Remaining: $seconds_remaining"
		incr seconds_remaining -1
		after 1000 des_countdown
	}

}

proc down_interface { } {

	global ppp_interface serial_port ip_address
	global ifconfig_cmd
	# check if i/f is up
	if { [string length $ppp_interface] < 1 } { return }
	puts "Taking down interface $ppp_interface"
	puts "spawn /usr/bin/pfsh"
	spawn /usr/bin/pfsh
	expect "\$ "
	puts "Sending /usr/sbin/ifconfig $ppp_interface down"
	exp_send "/usr/sbin/ifconfig $ppp_interface down\r"
	expect "\$ "
	set ppp_interface ""
	set ip_address ""
	close $spawn_id
}

proc close_pppd { } {

	#puts "proc close_pppd" 
	global ppp_interface serial_port  port_id 
	global connection_type ip_address spawn_id tip_id
	global pppd_pid pppd_id
	global kill_pppd

	if { [info exists connection_type] != 1 } { return }

	if { [info exists ppp_interface] != 1  || \
			[string length $ppp_interface] < 1 } {

		#puts "no ppp_interface found, trying to close spawn_id"

		if { $connection_type == "pppd" } {
			catch {
				exec pkill pppd
				exp_send ""
				#puts "kill -TERM $pppd_pid"
				catch { exec kill -TERM $pppd_pid }
				set kill_pid [exp_pid -i $spawn_id] 
				#puts "Sending kill to pid $kill_pid"
				exec kill -TERM $kill_pid
				#puts "pppd_pid == $pppd_pid"
			}
		
		} else {
			catch { [exp_send "~.\r"] }
		}
	} else {
		#puts "Looking for /var/run/[set ppp_interface].pid"
		set pppd_pid_file "/var/run/[set ppp_interface].pid"
		if { [file exists $pppd_pid_file] == 1 } {
			#puts "Executing $kill_pppd $pppd_pid_file"
			exec $kill_pppd $pppd_pid_file
		}
	}
	#puts "close_pppd done"

}

proc get_interface_info { ip_address } {
	global ppp_interface \
					serial_port \
					ip_address \
					remote_ip_address


					puts "find i/f based on $ip_address"
					set if_fd [open "|ifconfig"]
					set save ""
				while { [gets $if_fd line] != -1 } {
						puts "i/f line: $line"
						if { [string first $ip_address $line] != -1 } {
							#puts "found $ip_address in $line"
							#puts "looking for i/f name in: $save"
							set ppp_interface [lindex [split $save " "] 0]
							puts "ppp_interface: $ppp_interface"
						}
				}
}

proc disconnect { reason } {
	
	#puts "proc disconnect $reason" 

	global accounts
	global active_account 
	global challenge_entered
	global des_response
	global seconds_remaining
	set seconds_remaining 30
	global connection_state
	set challenge_entered "false"
	global pppd_id pppd_pid tip_id
	global link_disconnected 
	set link_disconnected "true"

	global ppp_interface serial_port ip_address
	global connection_type
	set connection_state "disconnecting"

	# connection scripts
	pre_disconnect

	log_message "Disconnecting: $reason "
	.footer.footer_r configure -text "Disconnecting: $reason" -justify left
	catch { destroy .des_dialog }

	global backup_resolv
	global manage_resolv

	# restore resolv.conf
	if { $accounts($active_account,resolv) == 1 } {
		puts "restoring file $backup_resolv"
		if { [file exists $backup_resolv] == 1 } {
			exec $manage_resolv restore $backup_resolv
		} 
	}
	if { [info exists ppp_interface] != 1 ||
					[string length $ppp_interface] < 1 } {
					log_message "Unable to determine ppp interface, trying IP address" 
				# see if ip_address present
				if { [info exists ip_address] != 1  ||
							[string length $ip_address] < 1 } {
					log_message "Unable to determine ip interface, exit ppptool to reset"
					#puts "close_pppd (a)"
					close_pppd
					close_ppp_tunnel
				} else {
				
					puts "find i/f based on $ip_address"
					set if_fd [open "|ifconfig -a"]
					set save ""
					while { [gets $if_fd line] != -1 } {
						#puts "i/f line: $line"
						if { [string first $ip_address $line] != -1 } {
							#puts "found $ip_address in $line"
							#puts "looking for i/f name in: $save"
							set ppp_interface [lindex [split $save " "] 0]
							#puts "ppp_interface: $ppp_interface"
							break
						}
						set save $line
					}
					close $if_fd
					log_message "Taking down interface $ppp_interface"
					if { [string length $ppp_interface] > 0 } {
						#puts "Terminating pppd process (a)"
						#puts "close_pppd (b)"
						close_pppd
						close_ppp_tunnel
					}
					
				}
			} else {

				#puts "Taking down interface $ppp_interface"
				#puts "Terminating pppd process (b)"
				#down_interface
				#puts "close_pppd (c)"
				close_pppd
				close_ppp_tunnel
			}


	.connect configure -state disabled 
	sleep 3
	.connect configure -text "Connect" -command connect  -state normal
	#puts "disconnect done"
	set link_disconnected "true"
	# connection script
	post_disconnect
}

proc init_modem { } {

		global connection_state
		global baud_rate
		global ppp_settings
		#puts "init_modem"
		global spawn_list

		global ppp_settings
		set init_string "AT &F1"

		if { [info exists ppp_settings(init_string)] && \
				 [string length $ppp_settings(init_string)] > 2 } {

				set init_string $ppp_settings(init_string)
		} 
		puts "set error catch  system stty -F $ppp_settings(modem_port) -echoe -echo raw $ppp_settings(port_speed) err"
		set error [catch { [system "stty -F $ppp_settings(modem_port) -echoe -echo raw $ppp_settings(port_speed)"] } err]
		if { $error != 1 } {
			#puts "Error setting baud rate for modem on port $ppp_settings(modem_port)"
			return -1
		}
####################11111111111111111111####################
#	if 	[spawn -noecho -open [ open $ppp_settings(modem_port) "RDWR NONBLOCK"]] != 0 
####################11111111111111111111####################
	set timeout 5
	puts "open modem"
	global port_id

	#if { [info exists port_id] } {
	#	puts "closing $port_id"
	#	catch { close $port_id }
	#} 
	# if initialized by modempool_connect, port may be open

  set port_id ""
		puts "spawn -noecho -open \[ open $ppp_settings(modem_port) RDWR NONBLOCK\]\]" 
		if {	[spawn -noecho -open [ open $ppp_settings(modem_port) "RDWR NONBLOCK"]] != 0 } {
			#set connection_state "unconnected"
			puts "error initializing modem"
			return -1
		}   else {
			lappend spawn_list $spawn_id
			puts "set port_id $spawn_id"
			set port_id $spawn_id
			puts "exp_send -i $port_id ATZ"
			exp_send -i $port_id "ATZ\r"
			expect {
				-i $port_id "OK" {
						#puts "Sending init string $init_string"
					 exp_send -i $port_id "$init_string\r" 
				}
				-i $port_id "NO CARRIER" {
				puts "NO CARRIER detected, initializing with $init_string"
				sleep 2
				exp_send -i $port_id "$init_string\r" 
				#catch { close $port_id }
				#set connection_state "unconnected"
				return 0 
				}
				-i $port_id timeout {
					#set connection_state "unconnected"
					puts "Timeout waiting for OK from AT command"
					.footer.footer_r configure -text "Modem not responding, quit ppptool and restart\n"
					#puts "closing $port_id"
					catch { close $port_id }
					return -1
				}
			}
			expect { 
				-i $port_id "NO CARRIER" {
					catch { close $port_id }
					#set connection_state "connecting"
					return 0 
				}
				-i $port_id "OK" {
					#puts "init_modem successful"
					#set connection_state "connecting"
					catch { close $port_id }
					return 0
			}
				-i $port_id timeout {
					#set connection_state "unconnected"
					puts "timeout waiting for OK from AT command"
					.footer.footer_r configure -text "Modem not responding, quit ppptool and restart\n"
					catch { close $port_id }
					return -1
			}
		}
	 }
 }
proc create_des_dialog { } {

	global accounts
	global active_account 
	global challenge_entered
	global des_response
	global seconds_remaining
	set seconds_remaining 30
	global connection_state
	set challenge_entered "false"
	global ppp_interface serial_port ip_address

 		toplevel .des_dialog
		entry .des_dialog.des_entry -width 20
		label .des_dialog.challenge_label -text "Host:  Challenge:"
		label .des_dialog.instruction_label -text "\n\
					 Get your DES card ready\n\
					 Enter your authorization number\n\
					 Then get ready to key in the Host Number\n\
					 and Challenge when they appear above\n\n\
					 Then press 'E' and wait for the response string,\n\
					 and enter the 'response' from your DES card\n\
					 into the entry box above"

		label .des_dialog.time_remaining -text "Waiting for Remote Connection"
		log_messages "Waiting for Remote Connection"
		button .des_dialog.des_send_button -text "Send Response" \
		-command { 
				global des_response challenge_entered seconds_remaining
				set des_response [.des_dialog.des_entry get]	
				set challenge_entered "true"
				#wm withdraw .des_dialog
				set seconds_remaining "null"
				destroy .des_dialog
		}	
		button .des_dialog.close -text "Close" \
		-command {

			#wm iconify .des_dialog
			set seconds_remaining "null"
			destroy .des_dialog
		}
		pack .des_dialog.challenge_label -anchor n
		pack .des_dialog.des_entry -after .des_dialog.challenge_label
		pack .des_dialog.instruction_label -anchor n
		pack .des_dialog.time_remaining -anchor n
		pack .des_dialog.des_send_button -side left -anchor n
		pack .des_dialog.close -side right -anchor n 
}

proc connect { } {

	global accounts
	global active_account 
	global challenge_entered
	global des_response
	global seconds_remaining
	set seconds_remaining 30
	global connection_state
	set challenge_entered "false"
	global ppp_interface serial_port ip_address

	# pre-connection scripts
	pre_connect

	log_messages "Connecting"
	sleep 1
	set connection_state "connecting"
	init_blinking_bulbs
	.footer.footer_r configure -text "Connecting .."

	global backup_resolv
	set backup_resolv "" 
	global manage_resolv

	.connect configure -state disabled
 
	if { $accounts($active_account,resolv) == 1 } {

		# create resolv.conf, backup resolv.conf
		if { [file exists $accounts($active_account,resolv_file)] == 1 } {
			set backup_resolv "/etc/resolv.conf.ppp"
			# backup 'to'
			exec $manage_resolv backup $backup_resolv 
			# copy 'from'
			exec $manage_resolv copy $accounts($active_account,resolv_file)
		} else {
			set backup_resolv "" 
		}

	}
	set connection_state "connecting"

	if { $accounts($active_account,authtype) == "tokencard" } {

		.footer.footer_r configure -text "Connecting .." 
	#  		toplevel .des_dialog
	# 		entry .des_dialog.des_entry -width 20
	# 		label .des_dialog.challenge_label -text "Host:  Challenge:"
	# 		label .des_dialog.instruction_label -text "\n\
	# 					 Get your DES card ready\n\
	# 					 Enter your authorization number\n\
	# 					 Then get ready to key in the Host Number\n\
	# 					 and Challenge when they appear above\n\n\
	# 					 Then press 'E' and wait for the response string,\n\
	# 					 and enter the 'response' from your DES card\n\
	# 					 into the entry box above"
	# 
	# 		label .des_dialog.time_remaining -text "Waiting for Remote Connection"
	# 		log_messages "Waiting for Remote Connection"
	# 		button .des_dialog.des_send_button -text "Send Response" \
	# 		-command { 
	# 				set des_response [.des_dialog.des_entry get]	
	# 				set challenge_entered "true"
	# 				#wm withdraw .des_dialog
	# 				set seconds_remaining "null"
	# 				destroy .des_dialog
	# 		}	
	# 		button .des_dialog.close -text "Close" \
	# 		-command {
	# 
	# 			#wm iconify .des_dialog
	# 			set seconds_remaining "null"
	# 			destroy .des_dialog
	# 		}
	# 		pack .des_dialog.challenge_label -anchor n
	# 		pack .des_dialog.des_entry -after .des_dialog.challenge_label
	# 		pack .des_dialog.instruction_label -anchor n
	# 		pack .des_dialog.time_remaining -anchor n
	# 		pack .des_dialog.des_send_button -side left -anchor n
	# 		pack .des_dialog.close -side right -anchor n 
		create_des_dialog
		modempool_connect
	} else {
		isp_connect
	}

}

proc restore_resolv { } {
	global accounts
	global active_account
	global backup_resolv
	exec $restore_resolv $backup_resolv
}

proc backup_resolv { } {
	global accounts
	global active_account
	global backup_resolv
	set backup_resolv [exec $backup_resolv]
}

proc create_resolv { } {
	global accounts
	global active_account
	#account_strings(domain) "DNS Domain Name:"
	#account_strings(ns1) "Account Nameserver #1:"
	#account_strings(ns2) "Account Nameserver #2:"

	exec $create_resolv \
	$account_strings($active_account,domain) \
	$account_strings($active_account,ns1) \
	$account_strings($active_account,ns2) 
}


proc monitor_link { } {
	#puts "monitor_link"
	global ppp_interface serial_port ip_address remote_ip_address
	global link_disconnected  mtu port_speed ppp_settings
	if { $link_disconnected == "true" } { return 0 }

	if { [info exists mtu] != 1 } { set mtu "" }
	if { [info exists port_speed] != 1 } { 
		set port_speed "" 
	} elseif { [info exists $ppp_settings(port_speed)] != 1 } { 
		set port_speed $ppp_settings(port_speed) 
	}

	set timeout 10
	global ip_up_file
	global ip_down_file
	# global ip_up_array
	# read ip-up output file

	if { [string length $remote_ip_address] < 6 } {
		puts "Unable to monitor link, no valid remote_ip_address"
	}
	# check that ppp_interface is a gateway
	#0.0.0.0         192.168.1.1     0.0.0.0         UG       40 0          0 eth0
	set save ""
	# retry if remote gateway not up immediately
	set max_retries 3

	for { set j 1 } { $j <= $max_retries } { incr j } {
		set gateway_list {}
		set ppp_gateway "false"
		set netstat_fd [open "|netstat -rn"]

		while { [gets $netstat_fd line] != -1 } {
				if {	[string first "UG" $line] != -1 ||
							[string first "UH" $line] != -1 } {
					# save all gateways
					lappend gateway_list $line
					if { [string first $ppp_interface $line] != -1 } {
						if { [string first $remote_ip_address $line] != -1 } {
							#puts "found $remote_ip_address in $line"
							set ppp_gateway "true"
						}
					}
				}
		}
		catch { close $netstat_fd }
		#puts "Gateways: [join $gateway_list \"\n\"]"
		if { $ppp_gateway == "true" } { 
			set j [expr $max_retries + 1]	
			break
		} else {
			#puts "No ppp gateway found, trying again .."
			#.footer.footer_bottom config -text "No ppp gateway found, retrying ($j of $max_retries)" 
			#pack .footer.footer_bottom -anchor s
			sleep 10	
		}
	}

	if { $ppp_gateway == "false" } {
				puts "No gateway found for $ppp_interface"
				set connection_state "disconnected"
				puts "disconnecting .."
				disconnect "No gateway found for $ppp_interface"
				return -1
	} else {
		#destroy .footer.footer_bottom
			.footer.footer_r configure -text \
			"Connected:\n\
			Network Interface: $ppp_interface\n\
			IP address: $ip_address\n\
			MTU: $mtu\n\
			Port Speed: $port_speed\n\
			Remote IP address: $remote_ip_address\n" \
			-font {times 10 bold} -justify left
	}

	log_user 0	
	spawn ping -c 1 $remote_ip_address 
	expect eof 
	log_user 1
	if { [string first \
				"1 packets transmitted, 1 received" $expect_out(buffer)] < 0 } {
				puts "Cannot reach $remote_ip_address, link may have gone down"
				.footer.footer_r config -text "Cannot reach $remote_ip_address, \
				link may have gone down"
				log_message "[exec date]: Cannot reach $remote_ip_address, \
				link may have gone down\n"
				set connection_state "disconnected"
				sleep 2
				puts "disconnecting .."
				disconnect "link may have gone down" 
				return -1
	}  else {
			set connection_state "connecting"
			after 10000 monitor_link
	}
}

proc isp_connect { } {
	#puts "proc isp_connect { } "

	global 	accounts account_list active_account baud_rate 
	global	env flow_control init_string ip_enabled 
	global 	log_file log_messages message modem_port
	global 	nat_transparency_mode network_interface 
	global 	password phone_number
	global	port port_speed spawn_id tokencard_response username
	global baud_rate pppd_config_file username
	global spawn_list ip_up_file

	global connection_state
	global pppd_id
	global pppd_pid
	global ppp_interface serial_port ip_address remote_ip_address
	global link_disconnected 
	set link_disconnected "true" 
	set remote_ip_address "0.0.0.0"
	#set connection_state "connecting"

	# remote ip_up_file
	#puts "removing $ip_up_file"
	catch { exec rm $ip_up_file }

	.passwdf.passwd_r configure -state normal

	global phone_number port baud_rate pppd pppd_config_file env username
	global tip_id
	global connection_type
	set connection_type "pppd"
	global ppp_settings

	#set phone_number $accounts($active_account,number)

	# strip out non-numeric
	regsub -all "\[^0-9\]" $accounts($active_account,number) "" phone_number 

	set baud_rate $ppp_settings(port_speed) 
	set pppd_config_file "$env(HOME)/.ppptool/connect.script"
	set port $ppp_settings(modem_port)
	set pppd /usr/sbin/pppd
	set pppd_cmd "$pppd file $pppd_config_file"

	.footer.footer_r config -text "Connect: Creating chat script"

	set fd [open $pppd_config_file w]

	set username [.uidf.uid_r get] 
	set password [.passwdf.passwd_r get] 

	if { $username != $accounts($active_account,uid) } {
		set accounts($active_account,uid) $username
	}
	if { $password != $accounts($active_account,passwd) } {
		set accounts($active_account,passwd) $password
	}
	#puts "$phone_number $port $baud_rate $pppd_config_file $username $password"

	puts $fd $port
	puts $fd $baud_rate
	puts $fd debug
	puts $fd lock
	puts $fd noproxyarp
	puts $fd updetach
	puts $fd usepeerdns

	# flow control
	switch  $ppp_settings(flow_control) {
		"hardware" {puts $fd crtscts }
		"software" {puts $fd xonxoff }
		"none" {puts $fd  nocrtscts }
	}

	if { $accounts($active_account,defroute) == 1 } {
		puts $fd "defaultroute"
	} else {
		puts $fd "nodefaultroute"
	}
	puts $fd "noipdefault"
	puts $fd "user $username"
	puts $fd "password $password"

	puts $fd "connect '/usr/sbin/chat -v REPORT CONNECT ABORT BUSY ABORT \"NO CARRIER\" \"\" atdt$phone_number \"CONNECT\"'"

	close $fd
	set pppd_cmd "$pppd file $pppd_config_file"
	puts "$pppd_cmd"
	.footer.footer_r config -text "Connecting with Chat script"
	set timeout -1

	if { [init_modem] != 0 } {
		return
	}

	spawn /bin/sh
	set pppd_id $spawn_id
	expect "#"
	exp_send "PS1=\"# \"\r"
	expect "# "
	exp_send "$pppd_cmd\r"
	log_user 0
	
	.connect configure -text "Disconnect" -state normal -command  {
		catch { exec pkill pppd }
		.connect configure -text "Connect" -command connect 
	}
	#init_blinking_bulbs
	set connection_state "connecting"
	.footer.footer_r config -text "Starting Process:\n$pppd_cmd" -font {times 10 bold} -justify left
	set ctr 0
	log_user 0
	expect_background -i $pppd_id -re  "\[^\r]*\r\n"  {
			if { [string first "failed" $expect_out(0,string)] != -1 } {
					.footer.footer_r configure -text $expect_out(0,string) 
					.connect configure -state normal -text "Connect" -command connect
			}

			if { [string first "Hangup" $expect_out(0,string)] != -1 } {
					.footer.footer_r configure -text "Hangup from Modem"
					##set connection_state "disconnected"
					.connect configure -state normal

			}
			if { [string first "(SIGHUP)" $expect_out(0,string)] != -1 } {
					.footer.footer_r configure -text "Hangup from Modem"
					.connect configure -state normal
			}

			if { [string first "is locked by pid" $expect_out(0,string)] != -1 } {
				#Device /dev/term/b is locked by pid 6482
				#pppd exp6: Device /dev/term/b is locked by pid 6482

				set split_line [split $expect_out(0,string) "\[ \t]*"]
				set lock_pid [lindex $split_line [expr [llength $split_line] -1]] 
				#puts "Found locking pid $lock_pid, looking for /var/run/ files with pid"
				# look for file in /var/run containing pid
				foreach f [exec ls /var/run] {
					if { [regexp "pid$" $f] == 1 } {
						# check if file contains pid
						if { [exec cat "/var/run/$f"] == $lock_pid } {
							#send file name to close_pppd
							set ppp_interface [lindex [split $f "."] 0]
							#puts "Setting ppp_interface file name to $ppp_interface"
							#puts "Running close_pppd"
							close_pppd 	
							break
						}
					}
				}
			}

			# look for connection success
			# Connect: sppp0 <--> /dev/term/b
			if { [string first "Connect" $expect_out(0,string)] != -1 } {
					set ppp_interface \
					[lindex [split $expect_out(0,string) " \t"] 1]

					set serial_port \
					[lindex [split $expect_out(0,string) " \t"] 3]
					puts "\nPPP Interface: $ppp_interface\n"
					puts "\nSerial port: $serial_port\n"
			}

			if {	[string first "local" $expect_out(0,string)] != -1 && \
						[string first "IP address" $expect_out(0,string)] != -1 } {

					set ip_address \
					[string trim [lindex [split $expect_out(0,string) "\[ ]*"] 4]]
					puts "\nIP address for interface: $ip_address\n"
					.footer.footer_r configure \
					-text "PPP Connected.\nNetwork Interface: $ppp_interface\nIP address: $ip_address" -anchor w -justify left
						.connect configure -state normal -text "Disconnect" -command {
							disconnect "Disconnected by User" 
							set link_disconnected "true" 
						}	
						set connection_state "connecting"
			}

			if {	[string first "remote" $expect_out(0,string)] != -1 && \
						[string first "IP address" $expect_out(0,string)] != -1 } {
					#remote IP address 32.97.116.34
					set remote_ip_address \
					[string trim [lindex [split $expect_out(0,string) "\[ ]*"] 3]]
					puts "\nRemote IP address for interface: $remote_ip_address\n"
					.footer.footer_r configure \
					-text "PPP Connected.\nNetwork Interface: $ppp_interface\nIP address: $ip_address\nRemote IP address: $remote_ip_address" -anchor w -justify left
						.connect configure -state normal -text "Disconnect" -command {
							disconnect "Disconnected by User" 
							set link_disconnected "true" 
						}
						set connection_state "connecting"
						set link_disconnected "false" 
						read_ip_up
						monitor_link
			}
			# rcvd [IPCP ConfAck id=0x8a <addr 32.100.234.63>]
			# local  IP address 32.100.234.63
			# remote IP address 204.146.246.229
			# pppd exp6: rcvd [IPCP ConfAck id=0x8a <addr 32.100.234.63>]
			# local  IP address 32.100.234.63
			# remote IP address 204.146.246.229

			# get pid 
			if { [string first "CONNECT" $expect_out(0,string)] != -1 && \
					[string first "started" $expect_out(0,string)] != -1 } {

					#puts "pppd $spawn_id"
					# the pid of the pppd 
					set pid_line [split $expect_out(0,string) "\[ \t]*"] 
					#puts "pid_line: $pid_line"

					# get last string of line
					set pid_string [lindex $pid_line end] 
					#puts "pid_string: $pid_string"

					set pppd_pid [string trimright [lindex [split $pid_string] 0] ")"]
					#puts "pppd_pid: $pppd_pid"
					.connect configure -state normal

			}

			#puts "pppd $spawn_id: $expect_out(0,string)"

			if { [string first "script failed" $expect_out(0,string)] != -1 } {
				disconnect "User disconnected or $expect_out(0,string)"
			}
			if { [string first "Terminating" $expect_out(0,string)] != -1 } {
				disconnect $expect_out(0,string)
			}
			log_message $expect_out(0,string)
		}
		log_user 1
		post_connect
}

proc modempool_connect { } {
	#puts "proc modempool_connect { } "
	global connection_type
	global connection_state 

	global 	accounts account_list active_account baud_rate \
	env flow_control init_string ip_enabled \
	log_file log_messages message modem_port \
	nat_transparency_mode network_interface \
	password phone_number \
	port port_speed spawn_id tokencard_response username \
	baud_rate pppd_config_file username \
	tip_id pkghome ppp_settings challenge_entered \
	des_response seconds_remaining link_disconnected \
	port_id start_pppd remote_ip_address mtu ip_up_file
	
  set connection_type "tip"
	set pppd_started "false"
	set link_disconnected "false" 
	set mtu 0
	set remote_ip_address "0.0.0.0"

	# remote ip_up_file
	#puts "removing $ip_up_file"
	catch { exec rm $ip_up_file }

	#set ppp_settings(init_string) "atz" 
	#set ppp_settings(connect_string) ""
	#set ppp_settings(port_speed) 38400
	#set ppp_settings(flow_control) hardware
	#set ppp_settings(modem_port) /dev/term/b
	#set ppp_settings(ppp_options) "" 

	set phone_number $accounts($active_account,number)
	set baud_rate $ppp_settings(port_speed) 
	set port_speed $ppp_settings(port_speed) 
	set pppd_config_file "$env(HOME)/.ppptool/connect.script"
	set port $ppp_settings(modem_port) 

	#set username $accounts($active_account,uid) 
	set username [.uidf.uid_r get] 
	if { $username != $accounts($active_account,uid) } {
		set accounts($active_account,uid) $username
	}
	# don't need passwd field
	.passwdf.passwd_r configure -state disabled
	.connect configure -text "Disconnect" -state disabled -command {
		disconnect "Disconnected by User" 
	} 
	.connect configure -state normal

	#puts "$phone_number $port $baud_rate $pppd_config_file $username"
	log_messages "$phone_number $port $baud_rate $pppd_config_file $username"


	if { [init_modem] != 0 } {
		return
	}
	#puts "Setting baud rate to $baud_rate"
	set error [catch { [system "stty -F $port -echoe -echo raw $baud_rate"] } err]
	if { $error != 1 } {
		puts "Error setting baud rate for modem on port $port"
	}

	set connection_state "connecting"
	.connect configure -text "Disconnect" -state normal -command { 
		disconnect "Disconnected by User" 
	}

	if { [info exists spawn_id] } {
		#puts "closing $spawn_id"
		catch { close $spawn_id }
	} 
	set timeout 90 
	if {	[catch { [spawn -noecho -open \
			 	[ open $ppp_settings(modem_port) "RDWR NONBLOCK" ]] } err]  != 1 } {
				#set connection_state "disconnected"
				log_messsage "error initializing modem: $err"
				return -1
	} else {
			# get model
			exp_send "$ppp_settings(init_string)\r" 
			log_user 0
			expect {
					 "OK"  { }
						"NO CARRIER" { }
						"BUSY" { } 
						"NO DIALTONE"	 { }
			}
			exp_send "ati3\r"
			expect {
				"OK" { 
						set model [lrange $expect_out(buffer) \
						[expr  [lsearch $expect_out(buffer) "ati3"] + 1] \
						[expr  [lsearch $expect_out(buffer) "OK"] - 1]] 
						puts "Modem_model: $model"
						log_message "Modem_model: $model"
					}
					"ERROR" {
						log_message "Unable to determine modem model"
						puts "Unable to determine modem model"
					}
			}
			exp_send "AT\r"
	}
	expect {
"Authentication failed." {
					puts "Check User ID/Password"
					log_message $expect_out(buffer)
					log_message "Check User ID/Password"
					.footer.footer_r configure -text \
					"Authentication failed.\nCheck User ID/Password" -anchor w -justify left
					create_des_dialog
					exp_continue
				}
				"NO CARRIER" {
					#set connection_state "disconnected"
					log_message $expect_out(buffer)
					#close_ppp_tunnel
					puts "Modem connection dropped" 
					.footer.footer_r configure -text "Modem connection dropped" 
					set connection_state "disconnected"
					log_message "Modem connection dropped" 
					#modempool_connect	
				}
				"EOT" {
					#set connection_state "disconnected"
					#puts "Received: $expect_out(buffer)"
					log_message "Modem disconnected"
					exp_continue
				}
				"all ports busy" { 
					#set connection_state "disconnected"
					log_message $expect_out(buffer)
					exp_send "~.\r"
					#catch { close $tip_id }
					#catch { close $spawn_id }
					#close_ppp_tunnel
					#sleep 10
					#modempool_connect	
				}	
				"NO DIAL TONE" { 
					#set connection_state "disconnected"
					log_message $expect_out(buffer)
					puts "NO DIAL TONE"
					.footer.footer_r configure -text "Modem connection closed" 
					 set connection_state "disconnected" 
					#close_ppp_tunnel
					#sleep 10
					#modempool_connect	
				}
				"OK" {
					log_message $expect_out(buffer)
					# dial
					#puts "Sending $phone_number"
					log_message "******************************\n"
					log_message "  Get your DES card ready"
					log_message "  Enter your authorization #"
					log_message "  Then get ready to key in:"
					log_message "  1.) Host number"
					log_message "  2.) Challenge"
					log_message "  Then enter the 'response' into the popup"
					log_message "******************************"

					puts "******************************\n"
					puts "  Get your DES card ready"
					puts "  Enter your authorization #"
					puts "  Then get ready to key in:"
					puts "  1.) Host number"
					puts "  2.) Challenge"
					puts "  Then enter the 'response' into the popup"
					puts "******************************"

					puts "Sending $phone_number to $spawn_id"

					exp_send "atdt $phone_number\r"
					exp_continue
				}

				# auth
				Username: { 
					log_message $expect_out(buffer)
					exp_send "$username\r" 
					exp_continue
				}
				password: { 
					log_message $expect_out(buffer)
					exp_send "\r" 
					exp_continue
				}

				# des card challenge/response
				Challenge {
					log_message $expect_out(buffer)
					exp_continue	
				}

				esponse?  { 
					log_message $expect_out(buffer)
					#puts "expect_out(0,string) = $expect_out(0,string)"
					#puts "expect_out(buffer) = $expect_out(buffer)"

					# pop up entry, display challenge
					#Challenge: 9 6024 Response? 0f68pc72


					if { [winfo exists .des_dialog] != 1 } {  return } 

					set host_challenge [lindex [split $expect_out(buffer)] 1]
					set secret [lindex [split $expect_out(buffer)] 2]

					.des_dialog.challenge_label configure -text \
					"Host: $host_challenge Challenge: $secret"

					puts "\nhost_challenge=$host_challenge"
					puts "secret=$secret"

					des_countdown
					.connect configure -text "Disconnect" -command {
							puts "Sending +++ to $spawn_id"
							exp_send "+++,ath0\r"
							exp_send "+++,ath0\r"
							exp_send "+++,ath0\r"
							exp_send "AT+++\r"
							exp_send "AT+++\r"
							exp_send "AT+++\r"
							exp_send "ATZ\r"
							puts "spawn id: $spawn_id"
							disconnect "User disconnected"
					} 

					tkwait variable challenge_entered

					if { [info exists des_response] == 1 } {
						puts "Challenge: $des_response"
						exp_send "$des_response\r" 
						set timeout -1
						#puts "Continuing .."
						exp_continue
					} else {
						puts "No challenge received"
						.footer.footer_r configure -text "Challenge Entry Interval Expired!\n"
						.connect configure -state disabled
						sleep 30
						disconnect "No challenge entered"
						exp_send "+++,ath0\r"
					}
				}

				"\}" {

						foreach line [split $expect_out(buffer) "\r\n"] {
							#puts "PPPD: $line"
							if { [string first "Your IP" $line] != -1 } {
								set ip_address [lindex [split $line " 	"] 4]	
								set ip_address [string trimright $ip_address "."]
								puts "IP address: $ip_address"
								set mtu [lindex [split $line "  "] 7]
								puts "MTU: $mtu"
								.footer.footer_r configure -text \
								"Connected:\nIP address: $ip_address\nMTU: $mtu" -font {times 10 bold} -justify left
								break
							}
						}
				
						if { $pppd_started == "false" } {	
							#puts "exec $start_pppd \
							$ppp_settings(modem_port) \
							$ppp_settings(port_speed)"
							eval exec $start_pppd \
							$ppp_settings(modem_port) \
							$ppp_settings(port_speed)
							set pppd_started "true" 
							#.footer.footer_r configure -text "pppd started" 
							.connect configure -text "Disconnect" -state normal -command {
								catch { exec pkill pppd }
								.connect configure -text "Connect" -command connect 
							} 
							#puts "Reading ip-up output file"
							read_ip_up
							#ppp_interface serial_port ip_address remote_ip_address port_speed mtu
							.footer.footer_r configure -text \
							"Connected:\n\
							IP address: $ip_address\n\
							MTU: $mtu\n\
							Port Speed: $port_speed\n\
							Remote IP address: $remote_ip_address\n" \
							-font {times 10 bold} -justify left
							post_connect
							monitor_link
						}

						log_message $expect_out(buffer)
						exp_continue
				}
				
				-re "(.*)>" {

							#puts "ppp prompt received"
							log_message $expect_out(buffer)
								#puts "Sending ppp"
								exp_send "ppp\r" 
								exp_continue
         }

				timeout {
					log_message $expect_out(buffer)
					#set connection_state "disconnected"
					#close_ppp_tunnel
					puts "timeout: try again"
					.footer.footer_r configure -text "Modem connection closed" 
					 set connection_state "disconnected" 
				}

				eof {
					#set connection_state "disconnected"
					log_message $expect_out(buffer)
					puts "eof: Modem connection closed"
					.footer.footer_r configure -text "Modem connection closed" 
					 set connection_state "disconnected" 
					#close_ppp_tunnel
				}
		}
	log_user 1
		return 0
}


proc post_connect { } {

	global post_connect_script

	if { [file exists $post_connect_script] } {
	 #puts "exec $post_connect_script"
	  exec $post_connect_script & 
	} 

	return
}


proc pre_connect { } {

	global pre_connect_script 

	if { [file exists $pre_connect_script] } {
	 #puts "exec $pre_connect_script" 
	  exec $pre_connect_script & 
	}

	return
}
proc pre_disconnect { } {

	global pre_disconnect_script 

	if { [file exists $pre_disconnect_script] } {
	 #puts "exec $pre_disconnect_script"
	  exec $pre_disconnect_script & 
	}

	return
}
proc post_disconnect { } {

	global post_disconnect_script 

	if { [file exists $post_disconnect_script] } {
	 #puts "exec $post_disconnect_script"
	  exec $post_disconnect_script & 
	}

	return
}

proc init { } {

	global port_opened
	set port_opened "false"

	global ppp_settings
	global env
	global ppp_dir
	global pkghome

	#puts "Connection Script Env 'USER_ID': $env(USER_ID)"
	#puts "Connection Script Env 'CONNECTION_TYPE': $env(CONNECTION_TYPE)"
	set pkghome $env(PKGHOME)

	
	global start_pppd
	set start_pppd "${pkghome}/start_pppd" 
	
	set copy_opts "[set pkghome]/copy_pppopts"	

	global manage_resolv
	set manage_resolv "[set pkghome]/manage_resolv"
	#"copy"  
	#"restore"
	#"srcfile=s"
	#"backup_file=s" 

	set ppp_dir "$env(HOME)/.ppptool" 

	global ppp_config_file
	set ppp_config_file "$ppp_dir/ppp_settings"
	#set ppp_config_file "$ppp_dir/ppp_config"

	global ppp_options_file
	set ppp_options_file "/etc/ppp/options"
	set ppp_options_template "[set pkghome]/options"

	#puts "Checking for $ppp_options_file file"
	if { [file exists $ppp_options_file] != 1 } {

		if { [file exists $ppp_options_template] != 1 } {
			#puts "Options file  $ppp_options_template not found"
			exit -1
		}

		#puts "$ppp_options_file file not found, creating .."
		if { [file exists $copy_opts] } {
			exec $copy_opts
			if { [file exists $ppp_options_file] != 1 } {
				#puts "Create of PPP options file $ppp_options_file failed!"
				exit -1
			}
		} else {
			#puts "File $copy_opts not found, cannot create $ppp_options_file file"
			exit -1
		}

	}

	# list
	global active_account
	global account_list
	set account_list {}

	# array (account_name,key)
	global accounts

	# connection scripts

  # User configurable scripts in $HOME/.connect
  global pre_connect_script
  global post_connect_script
  global pre_disconnect_script
  global post_disconnect_script

	if [file exists /etc/connect/pre-connect] {
		set pre_connect_script /etc/connect/pre-connect
	} else {
		set pre_connect_script "" 
	}
	if [file exists /etc/connect/post-connect] {
		set post_connect_script /etc/connect/post-connect
	} else {
		set post_connect_script "" 
	}
	if [file exists /etc/connect/pre-disconnect] {
		set pre_disconnect_script /etc/connect/pre-disconnect
	} else {
		set pre_disconnect_script "" 
	}
	if [file exists /etc/connect/post-disconnect] {
		set post_disconnect_script /etc/connect/post-disconnect
	} else {
		set post_disconnect_script "" 
	}
	
	global account_keys
	set account_keys {\
				 name\
				 uid\
				 passwd\
				 number\
				 domain\
				 search \
				 ns1\
				 ns2\
				 authtype\
				 defroute\
				 resolv\
				 status\
				 resolv_file\
	}

	global account_strings
	set account_strings(name) "Account Name:"
	set account_strings(uid) "User ID:"
	set account_strings(passwd) "Password:"
	set account_strings(number) "Phone Number:"
	set account_strings(domain) "DNS Domain Name:"
	set account_strings(search) "DNS Search Domains:"
	set account_strings(ns1) "Account Nameserver #1:"
	set account_strings(ns2) "Account Nameserver #2:"
	set account_strings(authtype) "Authentication Type:"
	set account_strings(defroute) "Default Route:"
	set account_strings(resolv) "Create /etc/resolv.conf:"
	
	global required_keys 
	set required_keys { name uid number authtype }

	global account_file
	set account_file "$ppp_dir/accounts"
	RandomInit [pid]

	if { [string first "sun" [exec arch]] != -1 } { 
		option add *font {palatino 12 bold} 
		option add *font {sun 12 bold} 
	}

	global log_file
	set log_file "$ppp_dir/ppp_log"

	global kill_pppd
	set kill_pppd "[set pkghome]/kill_pppd"

	load_global
	load_accts
	build_log_win
	build_menus

	global ip_up_file
	set ip_up_file "/etc/ppp/ip-up.out"
	if { [file exists $ip_up_file] } { exec rm $ip_up_file }
	global ip_down_file
	set ip_down_file "/etc/ppp/ip-down.out"
	if { [file exists $ip_down_file] } { exec rm $ip_down_file }

		#if_name=$1
		#tty_device=$2
		#speed=$3
		#local_ip=$4
		#remote_ip=$5
		#ipparam=$6
		#DNS1=$DNS1
		#DNS2=$DNS2
	global ip_up_array
	foreach key {
				if_name \
				tty_device \
				speed \
				local_ip \
				remote_ip \
				ipparam \
				DNS1 \
				DNS2 \
				PPPD_PID \
				PPPLOGNAME \
				SPEED \
				IPREMOTE \
				IFNAME \
				PATH \
				PWD \
				SHLVL \
				DEVICE \
				ORIG_UID \
				IPLOCAL } {
		set ip_up_array($key) ""
	}

}


proc read_ip_up { } {

	#puts "read_ip_up"
	global ip_up_file	\
			ppp_interface \
			serial_port \
			ip_address \
			remote_ip_address

		#if_name=$1
		#tty_device=$2
		#speed=$3
		#local_ip=$4
		#remote_ip=$5
		#ipparam=$6
		#DNS1=$DNS1
		#DNS2=$DNS2

		for { set i 0 } { $i < 12 } { incr i } {
			#puts "Checking for $ip_up_file"
			if { [file exists $ip_up_file] != 1 } {
				sleep 5
			} else {
				break
			}
		}

		if { [file exists $ip_up_file] != 1 } {
			#puts "file $ip_up_file not found"
			return -1
		}

			#puts "opening file $ip_up_file"
			set ip_fd [open $ip_up_file r]
			while { [gets $ip_fd line] != -1 } {
				#puts $line
				set ip_up_array([lindex [split $line "="] 0]) [lindex [split $line "="] 1]
			}
			close $ip_fd

			#puts "remote_ip_address $ip_up_array(remote_ip)"
			#puts "ip_address $ip_up_array(local_ip)"
			#puts "ppp_interface $ip_up_array(if_name)"
			#puts "serial_port $ip_up_array(tty_device)"

			set remote_ip_address $ip_up_array(remote_ip)
			set ip_address $ip_up_array(local_ip)
			set ppp_interface $ip_up_array(if_name)
			set serial_port $ip_up_array(tty_device)
			return 0
}

proc get_helptext { } {

return "\
<b>ITppptool Help\n\
\n\
\n\
PPPtool is a graphical interface for connecting to remote networks\n\
via dialup modem.\n\
\n\
The Main window consists of a Menu, a display of active account \n\
information, the 'Connect/Disconnect' Button, some mock \n\
'status lights', and a 'status' line.\n\
\n\
<b>Menu Items\n\
\n\
The Menu bar contains four menus:\n\
\n\
1. 'File'\n\
2. 'Edit',\n\
3. 'Accounts'\n\
4. 'Help'.\n\
\n\
\n\
The 'File' menu contains three items:\n\
\n\
1. Save Accounts\n\
2. View Log\n\
3. Exit\
\n\
\n\
The 'Edit' menu contains two items:\n\
\n\
1. Manage Accounts\n\
2. Edit Preferences\
\n\
\n\
The 'Accounts' menu is a dynamic menu and holds the names of all accounts\
which have been created.\n\
\n\
\n\
The 'Help' menu contains two items:\n\
\n\
1. 'About PPP Tool'\n\
2. 'PPP Tool Help'\n\
\n\
\n\
<b>Using ITppptool\n\
\n\
\n\
<b>I. Creating Accounts\n\
\n\
To create a new account, Select 'Edit/Manage Accounts'\n\
Click on 'New'. A window will appear with the following fields:\n\
( ** denotes a required field )\n\
\n\
\[ ** Account Name \]: Enter the name of the account\n\
\[ ** User ID \]: Enter the login name or ID of the account\n\
\[ Password \]: Enter the password of the account ( if one exists )\n\
\[ ** Phone Number \]: Enter the Phone Number of the account\n\
\[ DNS Domain Name \]: Enter the domain name of the account ( if one exists )\n\
\[ DNS Search Domains \]: Enter any domains which DNS should search\n\
\[ Account Nameserver #1 \]: Enter a primary nameserver for the account\n\
\[ Account Nameserver #2 \]: Enter a secondary nameserver for the account\n\
\n\
Near the bottom of the window are the following checkbuttons:\n\
\n\
\[ ** Authentication Type \]: Select the authentication protocol or method\n\
\[ Default Route \]: If selected, adds a 'default route' option to pppd\n\
\[ Create /etc/resolv.conf \]: If selected, copies the DNS information to /etc/resolv.conf\n\
\n\
\n\
<b>II.   Saving Accounts\n\
\n\
To save the current account information to the account file,\n\
select File/Save Accounts. If there have been any changes to\n\
the accounts, a prompt will pop up to confirm the save.\n\
Clicking 'Yes' will save the account data, clicking 'Cancel' will\n\
not save the account data and return to PPP tool.\n\ 
\n\
\n\
<b>III.  Editing Accounts\n\
\n\
To make changes to an account, first select Edit/Manage Accounts.\n\
Click on an account name in the window, then click on 'Edit'\n\
A window will appear with the account information.\n\
Edit any fields or select/deselect any items, then click on 'Save Edits'\n\
The window will close and the changes will be saved in the currently\n\
running program, but will NOT be save to the accounts file.\n\
To save the changes to the accounts file, select 'File/Save Accounts' and\n\
click on the 'OK' button\n\.
\n\
\n\
<b>IV.  Deleting Accounts\n\
\n\
To delete and account, first select Edit/Manage Accounts.\n\
Click on an account name in the window, then click on 'Delete'\n\
The account will be deleted in the currently running program, but will\n\
NOT be saved to the accounts file.  To save the changes to the accounts\n\
file, select 'File/Save Accounts' and click on the 'OK' button\n\.
\n\
\n\
<b>V.    Making an Account Active\n\
\n\
To make an account active means to make it available for connecting.\n\
There are two ways to do this:
1. Select the account from the 'Accounts' menu item in the main window.
2. In the 'Account Manager' window, select the account and click the\n\
'Make Active' button.\n\
\n\
\n\
<b>VI.   Preferences\n\
\n\
Upon first starting ppptool, a set of default preferences will be loaded.\n\
To make sure the correct settings are in effect, check the preferences\n\
window by selecting 'Edit/Edit Preferences'.\n\
The settings in the preferences are:\n\
\n\
Modem Port (required):  This is the port to which the modem is connected.\n\
Flow Control:  hardware, software, or none.\n\
Port Speed (required)\n\
Init String: Enter any modem initialization string here.\n\
Connect String: Reserved for future use\n\
PPP options: Reserved for future use\n\
\n\n\
<b>VII.  Connecting with PPPtool\n\
\n\
To initiate a connection, follow these steps:\n\
1. Select an account and make it active ( See V. above )\n\
2. Make sure your modem is connected to the correct port, and that\n\
the correct cable is connected between the modem and the computer.
3. Verify the account information is correct, then click on the 'Connect' Button.\n\
4. If possible, turn up the volume on the modem so that you can hear it going
off-hook, dialing, and connecting.\n\
5. Monitor the 'Status' line at the bottom of the main window, and the log\n\
window as well ( File/View Log ).\n\
\n\
\n\
<b>VIII. Exiting PPPtool\n\
\n\
To exit PPPtool, select 'File/Exit'. If there is any account information\n\
which has not been save to the account file, a dialog will pop up asking\n\
whether to save, cancel, or return to PPPtool. Clicking 'Yes' will save\n\
the account settings to the file. Clicking 'No' will exit PPPtool without\n\
saving the account changes, and clicking 'Cancel' will return to PPPtool\n\
without saving any changes to the accounts file.\n\
\n"
}

proc help { } {
		
		toplevel .help_win 
		wm title .help_win "ITppptool help"
		frame .help_win.help_frame -relief flat
		text .help_win.help_text -wrap word -relief sunken -borderwidth 2 \
		-yscrollcommand { .help_win.scroll_y set} \
		-height 20 -width 65 -setgrid true
		scrollbar .help_win.scroll_y -command ".help_win.help_text yview"
		pack .help_win.help_text -in .help_win.help_frame -side left -pady 1m -fill both
		pack .help_win.scroll_y -in .help_win.help_frame -side right -fill y

		frame .help_win.button_frame -relief flat
		button .help_win.close_button -text "Close" -command {\
			destroy .help_win
		}
		pack .help_win.close_button -side bottom -in .help_win.button_frame \
		-ipadx 2 -padx 2

		pack .help_win.help_frame .help_win.button_frame -side top

		.help_win.help_text tag configure bold \
		 -font  -*-times-bold-r-normal--*-160-* 

		.help_win.help_text tag configure normal \
		-font -*-times-medium-r-normal--*-160-*

		set helptext [split [get_helptext] "\n"]
		foreach line $helptext {

			if { [string first "<b>" $line] != -1 } {
				regsub -all "<b>" $line "" newline
				.help_win.help_text insert end $newline bold 
				#.help_win.help_text insert end "\n" 
			} else {
				.help_win.help_text insert end $line normal
				.help_win.help_text insert end "\n" 
			}
		}
}
#test
#wow
init
@


1.8
log
@ok
@
text
@d3736 1
@


1.7
log
@good, and pops up des-dialog if auth fails
@
text
@d3735 1
a3735 1

@


1.6
log
@good
@
text
@d121 1
d135 2
a136 1
	exec expectk $target  "$@@" 
d467 2
a468 2
	if { $save_needed == "false" } {	

d470 1
a470 1
			#puts "Key=$key, value=$value"
d476 1
a476 1
				#puts "save_needed: info exists saved_accounts($key) != 1"
d480 48
a527 3
				#puts "save_needed: saved_accounts($key) != $value"
				set save_needed true
				break
d542 4
d548 2
a549 3
				set save_needed true
				break
			}
a554 1

a555 1

d820 2
d1356 1
a1356 2
		set after_interval [RandomRange 500 ] 

a1362 1

d1368 1
d1370 1
d1373 8
a1382 2
	

d1388 1
d1406 1
a1406 1
			#puts "bulbs($bulb,color) = $bulbs($bulb,color)"
d1413 1
a1413 1
				#puts "init_blinking: .cframe.can itemconfigure $bulb -fill $bulbs($bulb,color)" 
d1418 1
a1418 1
				#puts "Constant: .cframe.can itemconfigure $bulb -fill green" 
d1420 1
d1423 1
d1486 12
a1497 2
					foreach modem_port [exec ls /dev | grep ttyS\[0-9\] ] {
							set modem_port "/dev/[set modem_port]"
d2147 3
d2151 2
a2152 1
		#destroy .des_dialog
d2328 1
d2352 1
a2352 1
		#puts "set error catch  system stty -F $ppp_settings(modem_port) -echoe -echo raw $ppp_settings(port_speed) err"
d2364 7
a2370 4
	if { [info exists port_id] } {
		#puts "closing $port_id"
		catch { close $port_id }
	} 
d2372 1
a2372 1
		#puts "spawn -noecho -open \[ open $ppp_settings(modem_port) RDWR NONBLOCK\]\]" 
d2374 1
a2374 1
			set connection_state "unconnected"
d2379 1
a2379 1
			#puts "set port_id $spawn_id"
d2381 1
a2381 1
			#puts "exp_send -i $port_id ATZ"
d2389 5
a2393 3
				#puts "NO CARRIER detected"
				catch { close $port_id }
				set connection_state "unconnected"
d2397 1
a2397 1
					set connection_state "unconnected"
d2399 1
d2408 1
a2408 1
					set connection_state "unconnected"
d2413 1
a2413 1
					set connection_state "connecting"
d2418 1
a2418 1
					set connection_state "unconnected"
d2420 1
d2427 1
d2429 47
a2492 1
	set connection_state "disconnected"
d2502 1
a2502 1
	#.connect configure -state disabled
a2517 25

#  	# initialize modem
#  	set modem_init -1 
#  	set max_retries 3
#  	for { set i 1 } { $i <= $max_retries } { incr i } {
#  		if { [init_modem] != 0 } { 
#  			.footer.footer_r configure -text "Error Initializing Modem, retrying ($i of $max_retries)" 
#  			set modem_init -1
#  			sleep 1 
#  			continue
#  		} else {
#  			.footer.footer_r configure -text "Modem Initialized" 
#  			set modem_init 1 
#  			break
#  		}
#  	}
#  
#  	if { $modem_init != 1 } { 
#  		.footer.footer_r configure -text "Error Initializing Modem, check modem and ports" 
#  		.connect configure -state normal 
#  		return -1 
#  	}
# 
	init_blinking_bulbs
	#.connect configure -text "Connect" -command connect -state normal
a2518 3
	.connect configure -text "Disconnect" -state disabled -command {
		disconnect "Disconnected by User" 
	} 
d2523 36
a2558 35
 		toplevel .des_dialog
		entry .des_dialog.des_entry -width 20
		label .des_dialog.challenge_label -text "Host:  Challenge:"
		label .des_dialog.instruction_label -text "\n\
					 Get your DES card ready\n\
					 Enter your authorization number\n\
					 Then get ready to key in the Host Number\n\
					 and Challenge when they appear above\n\n\
					 Then press 'E' and wait for the response string,\n\
					 and enter the 'response' from your DES card\n\
					 into the entry box above"

		label .des_dialog.time_remaining -text "Waiting for Remote Connection"
		log_messages "Waiting for Remote Connection"
		button .des_dialog.des_send_button -text "Send Response" \
		-command { 
				set des_response [.des_dialog.des_entry get]	
				set challenge_entered "true"
				#wm withdraw .des_dialog
				set seconds_remaining "null"
				destroy .des_dialog
		}	
		button .des_dialog.close -text "Close" \
		-command {

			#wm iconify .des_dialog
			set seconds_remaining "null"
			destroy .des_dialog
		}
		pack .des_dialog.challenge_label -anchor n
		pack .des_dialog.des_entry -after .des_dialog.challenge_label
		pack .des_dialog.instruction_label -anchor n
		pack .des_dialog.time_remaining -anchor n
		pack .des_dialog.des_send_button -side left -anchor n
		pack .des_dialog.close -side right -anchor n 
d2595 1
a2595 1
	puts "monitor_link"
d2680 2
d2712 1
a2712 1
	set connection_state "connecting"
d2784 4
a2787 1
	log_user 0
d2791 2
d2794 1
d2800 2
a2801 1

d2804 1
a2925 1
	
d2975 3
a2982 2
	set timeout 60
	# close any tip_id's in case
d2984 3
a2992 17
	#for { set i 0 } { $i < 3 } { incr i } {
	#	if { [init_modem] != 0 } { 
	#		.footer.footer_r configure -text "Error Initializing Modem" 
	#		set modem_init -1
	#		sleep 1 
	#		continue
	#	} else {
	#		.footer.footer_r configure -text "Modem Initialized" 
	#		set modem_init 1 
	#		break
	#	}
	#}

	#if { $modem_init != 1 } { return -1 }

	init_blinking_bulbs
	#.connect configure -text "Connect" -command connect -state normal
d2997 1
a2997 4
	#if { [info exists port_id] } {
	#	puts "closing $port_id"
	#	catch { close $port_id }
	#} 
d3002 1
d3006 1
a3006 1
				puts "error initializing modem: $err"
d3025 1
d3028 1
a3036 1
					#disconnect
d3041 2
a3042 3
					#set connection_state "disconnected"
					#close_ppp_tunnel
					return
d3049 3
d3057 1
a3057 1
					#puts "Modem disconnected"
d3084 9
d3102 2
d3147 12
d3170 3
d3203 1
a3203 1
							.connect configure -text "Disconnect" -command {
d3496 1
@


1.5
log
@ok, with 'about' and 'help'
@
text
@a426 1

d428 3
a430 11
	global save_accounts_prompt env
	
	global env

	global accounts

	global saved_accounts

	global ppp_settings

	global ppp_dir
a431 1

a433 1

d435 3
a437 7
	global active_account

	global account_list
	global saved_account_list

	global account_keys
	global account_file
d536 1
a536 1
									#puts $account_w "$key\t$accounts($account_name,$key)"
d544 1
a544 1
									#puts $account_w "$key\t$accounts($account_name,$key)"
d2540 1
a2540 1
		puts "Gateways: [join $gateway_list \"\n\"]"
d2542 1
a2542 1
			set j 4	
d2681 1
d2814 1
@


1.4
log
@good, next one needs the 'puts' out
@
text
@d1 1
a1 1
#!/bin/sh -x
d222 1
a222 1
		puts "close_pppd"
d244 4
a247 1
	$Help add command -label "About PPP Tool" -command { puts "About PPP Tool" }
d411 2
a412 2
			puts "$key\t$value"
			puts $config_w "$key\t$value"
d428 1
a428 1
	puts "proc save_accounts"
d461 1
a461 1
		puts "llength account_list != llength saved_account_list"
d467 1
a467 1
		puts "account_list == saved_account_list"
d470 1
a470 1
				puts "lsearch saved_account_list $account == -1"
d474 2
a475 1
				puts "lsearch saved_account_list $account != -1"
d483 1
a483 1
			puts "Key=$key, value=$value"
d486 2
a487 2
			puts "info exists saved_accounts($key) :?"
			puts "saved_accounts($key) == $value :?"
d489 1
a489 1
				puts "save_needed: info exists saved_accounts($key) != 1"
d493 1
a493 1
				puts "save_needed: saved_accounts($key) != $value"
d500 1
a500 1
			puts "Key=$key, value=$value"
d503 2
a504 2
			puts "info exists accounts($key) :?"
			puts "accounts($key) = $value :?"
d506 1
a506 1
				puts "save_needed: info exists accounts($key) != 1"
d510 2
a511 2
				puts "save_needed: accounts($key) != $value"
				puts "accounts($key) != $value"
d550 2
a551 2
									puts "$key\t$accounts($account_name,$key)"
									puts $account_w "$key\t$accounts($account_name,$key)"
d558 2
a559 2
									puts "$key\t$accounts($account_name,$key)"
									puts $account_w "$key\t$accounts($account_name,$key)"
d647 1
a647 1
					puts "selected_account = $selected_account"
d676 1
a676 1
				 puts "selected_account = $selected_account"
d699 1
a699 1
			puts "current selection: $current_sel: len: [string length $current_sel]"
d711 2
a712 2
					puts "Comparing selected account $selected_account to\
					active account $active_account"
d805 1
a805 1
			puts "key = $key"
d847 2
a848 2
				puts "resolv for account $edit_account_name = \
							$accounts($edit_account_name,resolv)"
d851 1
a851 1
				puts "resolv == $resolv"
a930 1
								puts "924"
d938 1
a938 1
								puts "=====> $key: $key_value" 
d947 2
a948 2
										puts "replacing $edit_account_name with $new_account_name\
										at index $replace_index"
d951 1
a951 1
										puts "account_list == $account_list"
d977 1
a977 1
					puts "accounts($new_account_name,$key) = $value" 
d988 2
a989 2
				puts "account name: $new_account_name"
				puts "account string: $new_account_string"
d993 1
a993 1
					puts "accounts($new_account_name,$key) = $value" 
d1008 2
a1009 2
						puts "deleting $item from account list at index \
						[lsearch $account_box_items $item]"
d1018 2
a1019 2
				puts "Comparing edited account $edit_account_name to\
				active account $active_account"
d1083 1
a1083 1
			puts "key = $key"
d1175 1
a1175 1
					puts "-------> Key $key" 
d1201 1
a1201 1
								puts "----> key: $key key_value: $key_value" 
d1237 2
a1238 2
					puts "account name: $account_name"
					puts "account string: $account_string"
d1242 1
a1242 1
						puts "accounts($account_name,$key) = $value" 
d1249 1
a1249 1
					puts "resolv.conf file is $accounts($account_name,resolv_file)"
d1285 1
a1285 1
	puts "Opening resolv_file $resolv_file"
d1420 1
a1420 1
					puts "$ppp_setting = $ppp_settings($ppp_setting)"
d1423 1
a1423 1
					puts "$ppp_setting = $ppp_settings($ppp_setting)"
d1444 2
a1445 2
							puts "[set ppp_setting]_menu add command -label $modem_port -command"
							puts "ppp_settings: [array names ppp_settings]"
d1457 2
a1458 2
							puts "[set ppp_setting]_menu add command -label $flow_control -command"
							puts "ppp_settings: [array names ppp_settings]"
d1474 2
a1475 2
					puts "[set ppp_setting]_menu add command -label $port_speed -command"
					puts "ppp_settings: [array names ppp_settings]"
d1493 1
a1493 1
				puts "ppp_setting $ppp_setting"
d1545 2
a1546 2
				puts "saved ppp_setting $ppp_setting as \
				[.prefs.pref_frame.[set ppp_setting]_frame.[set ppp_setting]_entry get]"
d1549 2
a1550 2
				puts "port_speed == $port_speed"
				puts "$ppp_setting = [set [set ppp_setting]]"
d1552 1
a1552 1
				puts "saved ppp_setting $ppp_setting as $ppp_settings($ppp_setting)" 
d1634 1
a1634 1
				puts "Setting account $acct to 'active' status"
d1639 1
a1639 1
				puts "Setting account $acct to 'inactive' status"
d1737 1
a1737 1
			puts "Setting account $acct to 'active' status"
d1740 1
a1740 1
			puts "Setting account $acct to 'inactive' status"
d1785 1
a1785 1
	puts "Looking for menu entry $name"
d1799 1
a1799 1
	puts "Deleting index $name at index $index"
d1802 3
a1804 3
	puts "account_list now contains: $account_list"
	puts "accounts now contains:"
	puts [array get accounts]
d1852 1
a1852 1
		puts "exec chown $env(USER_ID) $ppp_config_file"
d1856 1
a1856 1
		puts "Reading $ppp_config_file"
d1862 1
a1862 1
			puts "set ppp_settings([lindex $split_line 0]) [lindex $split_line 1]"
d1907 1
a1907 1
					puts "Key=$key"
d1909 1
a1909 1
					puts "Value=$value"
d1913 1
a1913 1
						puts "Invalid key $key found in account file $acct"
d1920 1
a1920 1
						puts "Account $value"
d1924 1
a1924 1
					puts "Adding key '$key' value '$value' to saved_accounts"
d1931 1
a1931 1
			puts "Loaded saved_accounts"
d1967 1
a1967 1
					puts "Key=$key"
d1969 1
a1969 1
					puts "Value=$value"
d1973 1
a1973 1
						puts "Invalid key $key found in account file accounts"
d1981 1
a1981 1
						puts "Account $value"
d1984 1
a1984 1
						puts "Adding account name $account_name to account_list"
d1986 1
a1986 1
						puts "Adding account name $account_name to saved_account_list"
d1988 1
a1988 1
							puts "Adding key '$key' value '$value' to accounts"
d1990 1
a1990 1
							puts "Adding key '$key' value '$value' to saved_accounts"
d1993 1
a1993 1
							puts "Adding key '$key' value '$value' to accounts"
d1995 1
a1995 1
							puts "Adding key '$key' value '$value' to saved_accounts"
d2002 1
a2002 1
				puts "verifying accounts"
d2005 2
a2006 2
								puts "key $key"
								puts "account $account"
d2008 2
a2009 2
										puts "key $key not found in accounts file"
										puts "set accounts($account,$key)"
d2028 1
a2028 1
  puts "proc close_ppp_tunnel {} "
d2041 1
a2041 1
			puts "Sending kill -TERM $pppd_pid"
d2055 1
a2055 1
	 puts "close_ppp_tunnel done"
d2061 1
a2061 1
  puts "proc log_messages {message} "
d2124 1
a2124 1
	puts "proc close_pppd" 
d2135 1
a2135 1
		puts "no ppp_interface found, trying to close spawn_id"
d2141 1
a2141 1
				puts "kill -TERM $pppd_pid"
d2144 1
a2144 1
				puts "Sending kill to pid $kill_pid"
d2146 1
a2146 1
				puts "pppd_pid == $pppd_pid"
d2153 1
a2153 1
		puts "Looking for /var/run/[set ppp_interface].pid"
d2156 1
a2156 1
			puts "Executing $kill_pppd $pppd_pid_file"
d2160 1
a2160 1
	puts "close_pppd done"
d2187 1
a2187 1
	puts "proc disconnect $reason" 
d2229 1
a2229 1
					puts "close_pppd (a)"
d2238 1
a2238 1
						puts "i/f line: $line"
d2251 2
a2252 2
						puts "Terminating pppd process (a)"
						puts "close_pppd (b)"
d2261 1
a2261 1
				puts "Terminating pppd process (b)"
d2263 1
a2263 1
				puts "close_pppd (c)"
d2271 1
a2271 1
	puts "disconnect done"
d2282 1
a2282 1
		puts "init_modem"
d2293 1
a2293 1
		puts "set error catch  system stty -F $ppp_settings(modem_port) -echoe -echo raw $ppp_settings(port_speed) err"
d2296 1
a2296 1
			puts "Error setting baud rate for modem on port $ppp_settings(modem_port)"
d2306 1
a2306 1
		puts "closing $port_id"
d2310 1
a2310 1
		puts "spawn -noecho -open \[ open $ppp_settings(modem_port) RDWR NONBLOCK\]\]" 
d2317 1
a2317 1
			puts "set port_id $spawn_id"
d2319 1
a2319 1
			puts "exp_send -i $port_id ATZ"
d2323 1
a2323 1
						puts "Sending init string $init_string"
d2327 1
a2327 1
				puts "NO CARRIER detected"
d2334 2
a2335 2
					puts "-> timeout waiting for OK from AT command <-"
					puts "closing $port_id"
d2347 1
a2347 1
					puts "init_modem successful"
d2548 1
a2548 1
							puts "found $remote_ip_address in $line"
d2555 1
a2555 1
		puts "Gateways: [join [list $gateway_list] '\n']"
d2560 1
a2560 1
			puts "No ppp gateway found, trying again .."
a2562 1

d2606 1
a2606 1
	puts "proc isp_connect { } "
d2627 1
a2627 1
	puts "removing $ip_up_file"
d2662 1
a2662 1
	puts "$phone_number $port $baud_rate $pppd_config_file $username $password"
d2731 1
a2731 1
				puts "Found locking pid $lock_pid, looking for /var/run/ files with pid"
d2739 2
a2740 2
							puts "Setting ppp_interface file name to $ppp_interface"
							puts "Running close_pppd"
d2756 2
a2757 2
					puts "\n==> PPP Interface: $ppp_interface <==\n"
					puts "\n==> serial port: $serial_port <==\n"
d2765 1
a2765 1
					puts "\n==> IP address for interface: $ip_address <==\n"
d2780 1
a2780 1
					puts "\n==> Remote IP address for interface: $remote_ip_address <==\n"
d2803 1
a2803 1
					puts "pppd $spawn_id"
d2806 1
a2806 1
					puts "pid_line: $pid_line"
d2810 1
a2810 1
					puts "pid_string: $pid_string"
d2813 1
a2813 1
					puts "pppd_pid: $pppd_pid"
d2818 1
a2818 1
			puts "pppd $spawn_id: $expect_out(0,string)"
d2833 1
a2833 1
	puts "proc modempool_connect { } "
d2855 1
a2855 1
	puts "removing $ip_up_file"
d2880 1
a2880 1
	puts "$phone_number $port $baud_rate $pppd_config_file $username"
d2918 1
a2918 1
		puts "closing $spawn_id"
d2929 1
d2939 4
a2942 3
						set modem_model $expect_out(buffer)
						set modem_model [lindex [split $expect_out(buffer) "\[^\r]*\r\n"] 3] 
						puts "Modem_model: $modem_model"
a2949 1

d2971 1
a2971 1
					puts "Received: $expect_out(buffer)"
d2998 1
a2998 1
					puts "Sending $phone_number"
d3002 1
a3002 1
					puts "  Then get read to key in:"
d3058 1
a3058 1
						puts "Continuing .."
d3070 1
a3070 1
							puts "PPPD: $line"
d3076 1
a3076 1
								puts "MTU:  $mtu"
d3084 1
a3084 1
							puts "exec $start_pppd \
d3096 1
a3096 1
							puts "Reading ip-up output file"
d3116 1
a3116 1
							puts "ppp prompt received"
d3118 1
a3118 1
								puts "Sending ppp"
d3141 1
d3151 1
a3151 1
	 puts "exec $post_connect_script"
d3164 1
a3164 1
	 puts "exec $pre_connect_script" 
d3175 1
a3175 1
	 puts "exec $pre_disconnect_script"
d3186 1
a3186 1
	 puts "exec $post_disconnect_script"
d3203 2
a3204 2
	puts "Connection Script Env 'USER_ID': $env(USER_ID)"
	puts "Connection Script Env 'CONNECTION_TYPE': $env(CONNECTION_TYPE)"
d3230 1
a3230 1
	puts "Checking for $ppp_options_file file"
d3234 1
a3234 1
			puts "Options file  $ppp_options_template not found"
d3238 1
a3238 1
		puts "$ppp_options_file file not found, creating .."
d3242 1
a3242 1
				puts "Create of PPP options file $ppp_options_file failed!"
d3246 1
a3246 1
			puts "File $copy_opts not found, cannot create $ppp_options_file file"
d3385 1
a3385 1
	puts "read_ip_up"
d3402 1
a3402 1
			puts "Checking for $ip_up_file"
d3411 1
a3411 1
			puts "file $ip_up_file not found"
d3415 1
a3415 1
			puts "opening file $ip_up_file"
d3418 1
a3418 1
				puts $line
d3423 4
a3426 4
			puts "remote_ip_address $ip_up_array(remote_ip)"
			puts "ip_address $ip_up_array(local_ip)"
			puts "ppp_interface $ip_up_array(if_name)"
			puts "serial_port $ip_up_array(tty_device)"
@


1.3
log
@ok, disconnects much better
@
text
@d157 1
a157 1

d245 1
a245 1
	$Help add command -label "PPP Tool Help" -command { puts "PPP Tool Help" }
d2552 1
a2552 1
		puts "Gateways: [list $gateway_list]"
d2595 1
a2595 1
				disconnect 
a2694 1
	lappend spawn_list $spawn_id
d2819 1
a2819 1
				disconnect $expect_out(0,string)
a3378 1
init
d3431 190
@


1.2
log
@bug in shell script at beginning not cd'ing to pkgdir correctly
@
text
@d1 1
a1 1
#!/bin/sh
d82 2
d104 1
a104 1
  cd `dirname $0`
d108 1
a108 1
  link_target=`ls -l $basename | awk '{print $NF}'`
d110 1
a110 1
  target=`basename $link_target`
d112 1
a112 1
  cd `dirname $link_target`
d120 1
a120 1
  exec expectk $target  "$@@" 
d124 1
a124 1
  cd `dirname $0`
d126 1
a126 1
echo "pppdir = `pwd`"
d132 1
a132 1
  target=`basename $0`
d134 1
a134 1
  exec expectk $target  "$@@" 
d371 1
a371 1
	global ppp_config_file
d414 1
d426 1
a426 1
	global save_accounts_prompt
d568 1
d1273 1
a1273 1
	global accounts	
d1299 1
d1814 1
a1814 1
	global ppp_dir
d1849 3
d2030 1
a2033 2
	puts "spawn_id = $spawn_id"

d2036 2
a2037 1
			exp_send ""
a2042 2
			# might as well try and close any tips
			catch { [exec pkill tip] }
d2044 1
a2044 1
		catch { exec kill -TERM $pppd_pid }
a2046 1
		
d2060 1
a2060 1
   global log_file
d2072 3
a2074 2
     puts $fd "$message\n"
     close $fd
a2104 1
	global spawn_list
a2109 1
	lappend spawn_list $spawn_id
d2122 1
a2122 1
	global ppp_interface serial_port  port_id spawn_list
d2136 1
a2143 1
				
a2156 20


 	#puts "exp_send -i $pppd_id logout"
 	#catch { exp_send -i $pppd_id "logout\r" }

 
 	#puts "exp_send -i $pppd_id pkill /usr/sbin/pppd" 
 	#catch { expect -i $pppd_id "#" }

	puts "spawn_ids:"
	foreach id $spawn_list {
		puts $id
	}
	foreach id $spawn_list {
		puts "close $id"
		catch { close $id }
	}
	# 	puts "send $port_id atz"
	# 	catch { exp_send -i $port_id "atz\r" }
	# 	catch { expect -i $port_id "OK" } 
d2203 1
a2203 1
	#pre_disconnect
d2271 1
a2271 1
	#post_disconnect
d2325 1
a2325 1
				#catch { close $port_id }
d2332 2
a2333 2
					#puts "closing $port_id"
					#catch { close $port_id }
d2339 1
a2339 1
					#catch { close $port_id }
d2346 1
a2346 1
					#catch { close $port_id }
d2352 1
a2352 1
					#catch { close $port_id }
d2373 1
a2373 1
	#pre_connect
d2403 22
a2424 22
	# initialize modem
	set modem_init -1 
	set max_retries 3
	for { set i 1 } { $i <= $max_retries } { incr i } {
		if { [init_modem] != 0 } { 
			.footer.footer_r configure -text "Error Initializing Modem, retrying ($i of $max_retries)" 
			set modem_init -1
			sleep 1 
			continue
		} else {
			.footer.footer_r configure -text "Modem Initialized" 
			set modem_init 1 
			break
		}
	}

	if { $modem_init != 1 } { 
		.footer.footer_r configure -text "Error Initializing Modem, check modem and ports" 
		.connect configure -state normal 
		return -1 
	}

d2429 1
a2429 1
		disconnect "Disconnected by User 1" 
a2469 2


a2566 1
				#.footer.footer_bottom config -text "No gateway found for $ppp_interface"
a2567 1
				sleep 2
d2569 1
a2569 2
				set reason "No gateway found for $ppp_interface"
				disconnect $reason 
a2627 15
	# create connect script
		# ttyb
		# 38400
		# debug
		# lock
		# noproxyarp
		# updetach
		# usepeerdns
		# crtscts
		# nodefaultroute
		# noipdefault
		# user internet.smus.MNGF11D
		# password tgrtgr 
		# connect '/usr/bin/chat -v REPORT CONNECT ABORT BUSY ABORT "NO CARRIER" "" atdt18005904857 "CONNECT"'

a2659 5

	#set username $accounts($active_account,uid) 
	#set password $accounts($active_account,passwd)


d2672 3
a2674 3
		"hardware" { puts $fd crtscts }
		"software" { puts $fd xonxoff }
		"none" { puts $fd  nocrtscts }
d2698 1
a2698 1
	exp_send "$pppd_cmd &\r"
d2700 4
a2703 3
	#.connect configure -text "Disconnect" -state normal -command  {
	#	disconnect "Disconnected by User 2" 
	#}
d2708 4
d2768 1
a2768 1
							disconnect "Disconnected by User 3" 
d2783 1
a2783 1
							disconnect "Disconnected by User 4" 
d2828 1
a2828 1
		#post_connect
a2884 8
	#### SOLARIS ####
	### catch { [exec pkill tip] } ###
	#### spawn tip "-$baud_rate" $port ###
	#### log_messages "spawn tip -$baud_rate $port"  ####
	#set tip_id $spawn_id

	#### LINUX ####

d2886 4
a2889 4
	#set error [catch { [system "stty -F $port -echoe -echo raw $baud_rate"] } err]
	#if { $error != 1 } {
	#	puts "Error setting baud rate for modem on port $port"
	#}
d2910 1
a2910 1
		disconnect "Disconnected by User 5" 
d2912 7
a2918 3
	if { [info exists port_id] } {
		puts "closing $port_id"
		catch { close $port_id }
a2925 1

d2927 7
a2935 1

d2937 7
a2943 7
								set modem_model $expect_out(buffer)
								set modem_model [lindex [split $expect_out(buffer) "\[^\r]*\r\n"] 3] 
								puts "Modem_model: $modem_model"
				}
				"ERROR" {
								puts "Unable to determine modem model"
				}
d2949 1
a2949 1
				"Authentication failed." {
a2963 1
					sleep 2
d2987 2
d3052 11
a3062 5
					puts "Challenge: $des_response"
					exp_send "$des_response\r" 
					set timeout -1
					puts "Continuing .."
					exp_continue
d3091 2
a3092 1
								disconnect "Disconnected by User 6" 
d3104 1
d3126 2
a3127 2
					#sleep 2
					#modempool_connect	
d3134 2
d3139 1
d3148 1
a3148 1
	  puts "exec $post_connect_script"
d3161 1
a3161 1
	  puts "exec $pre_connect_script" 
d3172 1
a3172 1
	  puts "exec $pre_disconnect_script"
d3183 1
a3183 1
	  puts "exec $post_disconnect_script"
a3190 1
	global spawn_list
a3432 291
# serial speed set to 38400 bps
# pppd exp6: serial speed set to 38400 bps
# 
# connect option: '/usr/bin/chat -v REPORT CONNECT ABORT BUSY ABORT "NO CARRIER" "" atdt18005904857 "CONNECT"' started (pid 1058)
# pppd exp6: connect option: '/usr/bin/chat -v REPORT CONNECT ABORT BUSY ABORT "NO CARRIER" "" atdt18005904857 "CONNECT"' started (pid 1058)
# 
# chat:  Feb 26 19:56:09 CONNECT 28800/ARQ/V34/LAPM/V42BIS
# Serial connection established.
# serial speed set to 38400 bps
# Using interface sppp0
# start_ppptool Connect: sppp0 <--> /dev/term/b
# pppd exp6: chat:  Feb 26 19:56:09 CONNECT 28800/ARQ/V34/LAPM/V42BIS
# Serial connection established.
# serial speed set to 38400 bps
# Using interface sppp0
# Connect: sppp0 <--> /dev/term/b
# 
# sent [LCP ConfReq id=0x91 <asyncmap 0x0> <magic 0x1504974d> <pcomp> <accomp>]
# pppd exp6: sent [LCP ConfReq id=0x91 <asyncmap 0x0> <magic 0x1504974d> <pcomp> <accomp>]
# 
# rcvd [LCP ConfAck id=0x91 <asyncmap 0x0> <magic 0x1504974d> <pcomp> <accomp>]
# pppd exp6: rcvd [LCP ConfAck id=0x91 <asyncmap 0x0> <magic 0x1504974d> <pcomp> <accomp>]
# 
# rcvd [LCP ConfReq id=0x1 <mru 1500> <asyncmap 0x0> <auth pap> <pcomp> <accomp>]
# sent [LCP ConfAck id=0x1 <mru 1500> <asyncmap 0x0> <auth pap> <pcomp> <accomp>]
# sent [LCP Ident id=0x92 magic=0x1504974d "ppp-2.4.0b1 (Sun Microsystems, Inc., Jul 31 2002 10:08:25)"]
# Authenticating to peer with PAP
# sent [PAP AuthReq id=0x1 user="internet.smus.MERICAA" password=<hidden>]
# pppd exp6: rcvd [LCP ConfReq id=0x1 <mru 1500> <asyncmap 0x0> <auth pap> <pcomp> <accomp>]
# sent [LCP ConfAck id=0x1 <mru 1500> <asyncmap 0x0> <auth pap> <pcomp> <accomp>]
# sent [LCP Ident id=0x92 magic=0x1504974d "ppp-2.4.0b1 (Sun Microsystems, Inc., Jul 31 2002 10:08:25)"]
# Authenticating to peer with PAP
# sent [PAP AuthReq id=0x1 user="internet.smus.MERICAA" password=<hidden>]
# 
# sent [PAP AuthReq id=0x2 user="internet.smus.MERICAA" password=<hidden>]
# pppd exp6: sent [PAP AuthReq id=0x2 user="internet.smus.MERICAA" password=<hidden>]
# 
# sent [PAP AuthReq id=0x3 user="internet.smus.MERICAA" password=<hidden>]
# pppd exp6: sent [PAP AuthReq id=0x3 user="internet.smus.MERICAA" password=<hidden>]
# 
# rcvd [LCP ConfReq id=0x2 <mru 1500> <asyncmap 0x0> <auth pap> <pcomp> <accomp>]
# sent [LCP ConfReq id=0x93 <asyncmap 0x0> <magic 0x90235e21> <pcomp> <accomp>]
# sent [LCP ConfAck id=0x2 <mru 1500> <asyncmap 0x0> <auth pap> <pcomp> <accomp>]
# pppd exp6: rcvd [LCP ConfReq id=0x2 <mru 1500> <asyncmap 0x0> <auth pap> <pcomp> <accomp>]
# sent [LCP ConfReq id=0x93 <asyncmap 0x0> <magic 0x90235e21> <pcomp> <accomp>]
# sent [LCP ConfAck id=0x2 <mru 1500> <asyncmap 0x0> <auth pap> <pcomp> <accomp>]
# 
# rcvd [LCP ConfAck id=0x93 <asyncmap 0x0> <magic 0x90235e21> <pcomp> <accomp>]
# sent [LCP Ident id=0x94 magic=0x90235e21 "ppp-2.4.0b1 (Sun Microsystems, Inc., Jul 31 2002 10:08:25)"]
# Authenticating to peer with PAP
# sent [PAP AuthReq id=0x4 user="internet.smus.MERICAA" password=<hidden>]
# pppd exp6: rcvd [LCP ConfAck id=0x93 <asyncmap 0x0> <magic 0x90235e21> <pcomp> <accomp>]
# sent [LCP Ident id=0x94 magic=0x90235e21 "ppp-2.4.0b1 (Sun Microsystems, Inc., Jul 31 2002 10:08:25)"]
# Authenticating to peer with PAP
# sent [PAP AuthReq id=0x4 user="internet.smus.MERICAA" password=<hidden>]
# 
# sent [PAP AuthReq id=0x5 user="internet.smus.MERICAA" password=<hidden>]
# pppd exp6: sent [PAP AuthReq id=0x5 user="internet.smus.MERICAA" password=<hidden>]
# 
# rcvd [PAP AuthAck id=0x5 ""]
# sent [IPCP ConfReq id=0x88 <addr 0.0.0.0> <compress VJ 0f 01> <ms-dns1 0.0.0.0> <ms-dns2 0.0.0.0>]
# sent [CCP ConfReq id=0x4d <deflate 15> <deflate(old#) 15> <bsd v1 15>]
# pppd exp6: rcvd [PAP AuthAck id=0x5 ""]
# sent [IPCP ConfReq id=0x88 <addr 0.0.0.0> <compress VJ 0f 01> <ms-dns1 0.0.0.0> <ms-dns2 0.0.0.0>]
# sent [CCP ConfReq id=0x4d <deflate 15> <deflate(old#) 15> <bsd v1 15>]
# 
# rcvd [IPCP ConfReq id=0x3 <addr 204.146.246.229>]
# sent [IPCP ConfAck id=0x3 <addr 204.146.246.229>]
# pppd exp6: rcvd [IPCP ConfReq id=0x3 <addr 204.146.246.229>]
# sent [IPCP ConfAck id=0x3 <addr 204.146.246.229>]
# 
# rcvd [IPCP ConfRej id=0x88 <compress VJ 0f 01> <ms-dns1 0.0.0.0> <ms-dns2 0.0.0.0>]
# sent [IPCP ConfReq id=0x89 <addr 0.0.0.0>]
# pppd exp6: rcvd [IPCP ConfRej id=0x88 <compress VJ 0f 01> <ms-dns1 0.0.0.0> <ms-dns2 0.0.0.0>]
# sent [IPCP ConfReq id=0x89 <addr 0.0.0.0>]
# 
# rcvd [LCP ProtRej id=0x4 80 fd 01 4d 00 0f 1a 04 78 00 18 04 78 00 15 03 2f]
# pppd exp6: rcvd [LCP ProtRej id=0x4 80 fd 01 4d 00 0f 1a 04 78 00 18 04 78 00 15 03 2f]
# 
# rcvd [IPCP ConfNak id=0x89 <addr 32.100.234.63>]
# sent [IPCP ConfReq id=0x8a <addr 32.100.234.63>]
# pppd exp6: rcvd [IPCP ConfNak id=0x89 <addr 32.100.234.63>]
# sent [IPCP ConfReq id=0x8a <addr 32.100.234.63>]
# 
# rcvd [IPCP ConfAck id=0x8a <addr 32.100.234.63>]
# local  IP address 32.100.234.63
# remote IP address 204.146.246.229
# pppd exp6: rcvd [IPCP ConfAck id=0x8a <addr 32.100.234.63>]
# local  IP address 32.100.234.63
# remote IP address 204.146.246.229
#-				## This won't work, it's not tip
#-				"Local command?" {
#-
#-              if { [string first "Your IP address is" $expect_out(buffer)] != -1 } {
#-                  puts "\n**** Found IP: $expect_out(buffer) ****\n"
#-                  foreach line [split $expect_out(buffer) "\r\n"] {
#-                    puts "PPPD: $line"
#-                    if { [string first "Your IP" $line] != -1 } {
#-											set ip_address [lindex [split $line " 	"] 4]	
#-											set ip_address [string trimright $ip_address "."]
#-											puts "IP address: $ip_address"
#-											set mtu [lindex [split $line "  "] 7]
#-											puts "MTU:  $mtu"
#-											.footer.footer_r configure -text "ppp Connected: $line" -font {times 10 bold} -justify left
#-                      break
#-                    }
#-                  }
#-              }
#-
#-								log_message $expect_out(buffer)
#-								#puts "exp_send /usr/bin/pppd debug lock updetach crtscts defaultroute noipdefault noccp novj\r"
#-								#exp_send "/usr/bin/pppd debug lock updetach crtscts defaultroute noipdefault noccp novj\r"
#-								puts "exp_send /usr/sbin/pppd debug lock crtscts defaultroute noipdefault noccp novj\r"
#-								exp_send "/usr/sbin/pppd debug lock crtscts defaultroute noipdefault noccp novj\r"
#-
#-								# best guess that connected is here
#-								post_connect
#-								
#-								exp_continue
#-				}
#- proc linux_isp_connect { } {
#- 	puts "proc linux_isp_connect { } "
#- 
#- 	global 	accounts account_list active_account baud_rate 
#- 	global	env flow_control init_string ip_enabled 
#- 	global 	log_file log_messages message modem_port
#- 	global 	nat_transparency_mode network_interface 
#- 	global 	password phone_number
#- 	global	port port_speed spawn_id tokencard_response username
#- 	global baud_rate pppd_config_file username
#- 
#- 	global connection_state
#- 	global pppd_id
#- 	global pppd_pid
#- 	global ppp_interface serial_port ip_address
#- 	global connection_state 
#- 
#- 	.passwdf.passwd_r configure -state normal
#- 
#- 	global phone_number port baud_rate pppd pppd_config_file env username
#- 	global tip_id
#- 	global connection_type
#- 	set connection_type "pppd"
#- 	global ppp_settings
#- 
#- 
#- 	# strip out non-numeric
#- 	regsub -all "\[^0-9\]" $accounts($active_account,number) "" phone_number 
#- 
#- 	set baud_rate $ppp_settings(port_speed) 
#- 	set pppd_config_file "$env(HOME)/.ppptool/connect.script"
#- 	set port $ppp_settings(modem_port)
#- 	set pppd /usr/sbin/pppd
#- 	set pppd_cmd "$pppd file $pppd_config_file"
#- 
#- 	set username [.uidf.uid_r get] 
#- 	set password [.passwdf.passwd_r get] 
#- 
#- 	if { $username != $accounts($active_account,uid) } {
#- 		set accounts($active_account,uid) $username
#- 	}
#- 	if { $password != $accounts($active_account,passwd) } {
#- 		set accounts($active_account,passwd) $password
#- 	}
#- 
#- 	puts "$phone_number $port $baud_rate $pppd_config_file $username $password"
#- 
#- 	# flow control
#- 	#switch  $ppp_settings(flow_control) {
#- 	#	"hardware" { puts $fd crtscts }
#- 	#	"software" { puts $fd xonxoff }
#- 	#	"none" { puts $fd  nocrtscts }
#- 	#}
#- 
#- 	if { $accounts($active_account,defroute) == 1 } {
#- 		puts $fd "defaultroute"
#- 	} else {
#- 		puts $fd "nodefaultroute"
#- 	}
#- 	puts $fd "noipdefault"
#- 	puts $fd "user $username"
#- 	puts $fd "password $password"
#- 
#- 	#puts $fd "connect '/usr/sbin/chat -v REPORT CONNECT ABORT BUSY ABORT \"NO CARRIER\" \"\" atdt$phone_number \"CONNECT\"'"
#- 
#- 	#close $fd
#- 	#set pppd_cmd "$pppd file $pppd_config_file"
#- 	#puts "$pppd_cmd"
#- 
#- 	.footer.footer_r config -text "Connecting with Chat script"
#- 
#- 	set timeout -1
#- 	#eval spawn $pppd_cmd
#- 	#set pppd_id $spawn_id
#- 
#- 	#.footer.footer_r config -text "Starting Process:\n$pppd_cmd" -font {times 10 bold} -justify left
#- 	set ctr 0
#- 
#- #- 	expect_background -i $spawn_id -re  "\[^\r]*\r\n"  {
#- #- 
#- #- 			if { [string first "Hangup" $expect_out(0,string)] != -1 } {
#- #- 					.footer.footer_r configure -text "Hangup from Modem"
#- #- 					#set connection_state "disconnected"
#- #- 					.connect configure -state normal
#- #- 
#- #- 			}
#- #- 			if { [string first "(SIGHUP)" $expect_out(0,string)] != -1 } {
#- #- 					.footer.footer_r configure -text "Hangup from Modem"
#- #- 					.connect configure -state normal
#- #- 			}
#- #- 
#- #- 			if { [string first "is locked by pid" $expect_out(0,string)] != -1 } {
#- #- 				# get pid and run close_pppd
#- #- 				#Device /dev/term/b is locked by pid 6482
#- #- 				#pppd exp6: Device /dev/term/b is locked by pid 6482
#- #- 
#- #- 				set split_line [split $expect_out(0,string) "\[ \t]*"]
#- #- 				set lock_pid [lindex $split_line [expr [llength $split_line] -1]] 
#- #- 				puts "Found locking pid $lock_pid, looking for /var/run/ files with pid"
#- #- 				# look for file in /var/run containing pid
#- #- 				foreach f [exec ls /var/run] {
#- #- 					if { [regexp "pid$" $f] == 1 } {
#- #- 						# check if file contains pid
#- #- 						if { [exec cat "/var/run/$f"] == $lock_pid } {
#- #- 							#send file name to close_pppd
#- #- 							set ppp_interface [lindex [split $f "."] 0]
#- #- 							puts "Setting ppp_interface file name to $ppp_interface"
#- #- 							puts "Running close_pppd"
#- #- 							close_pppd 	
#- #- 							break
#- #- 						}
#- #- 					}
#- #- 				}
#- #- 			}
#- #- 
#- #- 			# look for connection success
#- #- 			# Connect: sppp0 <--> /dev/term/b
#- #- 			if { [string first "Connect" $expect_out(0,string)] != -1 } {
#- #- 					set ppp_interface \
#- #- 					[lindex [split $expect_out(0,string) " \t"] 1]
#- #- 
#- #- 					set serial_port \
#- #- 					[lindex [split $expect_out(0,string) " \t"] 3]
#- #- 					puts "\n==> PPP Interface: $ppp_interface <==\n"
#- #- 					puts "\n==> serial port: $serial_port <==\n"
#- #- 			}
#- #- 
#- #- 			if {	[string first "local" $expect_out(0,string)] != -1 && \
#- #- 						[string first "IP address" $expect_out(0,string)] != -1 } {
#- #- 
#- #- 					set ip_address \
#- #- 					[string trim [lindex [split $expect_out(0,string) "\[ ]*"] 4]]
#- #- 					puts "\n==> IP address for interface: $ip_address <==\n"
#- #- 					.footer.footer_r configure \
#- #- 					-text "PPP Connected.\nNetwork Interface: $ppp_interface\nIP address: $ip_address" -anchor w -justify left
#- 						.connect configure -state normal -text "Disconnect"
#- 						set connection_state "connected"
#- #- 			}
#- #- 
#- #- 			# rcvd [IPCP ConfAck id=0x8a <addr 32.100.234.63>]
#- #- 			# local  IP address 32.100.234.63
#- #- 			# remote IP address 204.146.246.229
#- #- 			# pppd exp6: rcvd [IPCP ConfAck id=0x8a <addr 32.100.234.63>]
#- #- 			# local  IP address 32.100.234.63
#- #- 			# remote IP address 204.146.246.229
#- #- 
#- #- 			# get pid 
#- #- 			if { [string first "CONNECT" $expect_out(0,string)] != -1 && \
#- #- 					[string first "started" $expect_out(0,string)] != -1 } {
#- #- 
#- #- 					puts "pppd $spawn_id"
#- #- 					# the pid of the pppd 
#- #- 					set pid_line [split $expect_out(0,string) "\[ \t]*"] 
#- #- 					puts "pid_line: $pid_line"
#- #- 
#- #- 					# get last string of line
#- #- 					set pid_string [lindex $pid_line end] 
#- #- 					puts "pid_string: $pid_string"
#- #- 
#- #- 					set pppd_pid [string trimright [lindex [split $pid_string] 0] ")"]
#- #- 					puts "pppd_pid: $pppd_pid"
#- #- 					.connect configure -state normal
#- #- 
#- #- 			}
#- #- 
#- #- 			puts "pppd $spawn_id: $expect_out(0,string)"
#- #- 			log_message $expect_out(0,string)
#- #- 		}
#- 	
#- 		#post_connect
#- }
@


1.1
log
@Initial revision
@
text
@d122 2
a129 2
  cd `dirname $0`
#\
@
